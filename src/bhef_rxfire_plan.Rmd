--- 
title: "Black Hills Experimental Forest Prescribed Fire Planning"
author: "George Woolsey"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: 
  bookdown::gitbook: default
  # bookdown::render_book("index.Rmd", bookdown::gitbook(lib_dir = "src"))
documentclass: book
bibliography: [packages.bib]
biblio-style: apalike
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/research-institute-for-nature-and-forest.csl
suppress-bibliography: false
lang: en-US
zotero: true
link-citations: true
description: "Using the bookdown package to write a book for BHEF Rx fire planning. The output format for this example is bookdown::gitbook."
---

# Introduction

My name is George Woolsey and I am currently employed by the United States Forest Service working with [Dr. Mike Battaglia](https://www.fs.usda.gov/rmrs/people/mbattaglia) at the [Rocky Mountain Research Station](https://www.fs.usda.gov/rmrs/) in Fort Collins, Colorado. In addition, I am pursuing a MS in Forest Sciences at Colorado State University (CSU). At CSU I am working with Dr. Wade Tinkham in the [Forest Biometrics Lab](https://sites.warnercnr.colostate.edu/wtinkham/).

# Objective

The objective of this analysis is to describe the site conditions on the [Black Hills Experimental Forest](https://www.fs.usda.gov/rmrs/experimental-forests-and-ranges/black-hills-experimental-forest) (North Dakota, USA) for planning future prescribed fire treatments. This analysis incorporates the spatial location of research plots and some of the measurements collected at those plots (e.g. [Ritter et al. 2022](https://esajournals.onlinelibrary.wiley.com/doi/pdfdirect/10.1002/eap.2682)). In ponderosa pine (*Pinus ponderosa*) forests, prescribed fires and wildfires burning under moderate conditions can effectively reduce fuel loading and restore the structures and complex spatial patterns that existed in these forests historically ([Holden et al. 2007](https://link.springer.com/article/10.4996/fireecology.0302018); [Battaglia et al. 2008](https://www.sciencedirect.com/science/article/pii/S0378112708005872?casa_token=dFT72MfRci0AAAAA:-oOg81ItoxHaah1SeeRY9GdgcXgjBHgOhyZtbmk5U5e-IBFDgpEjNlFoo2P1wCvcKfj0a9dxCQQ)). 

In the ponderosa pine forests of the Black Hills, ladder fuels can develop quickly after a mechanical treatment if regeneration densities are not regulated. Prescribed fire can successfully maintain low regeneration densities following fuel treatments ([Battaglia et al. 2008](https://www.sciencedirect.com/science/article/pii/S0378112708005872?casa_token=dFT72MfRci0AAAAA:-oOg81ItoxHaah1SeeRY9GdgcXgjBHgOhyZtbmk5U5e-IBFDgpEjNlFoo2P1wCvcKfj0a9dxCQQ)). In addition to reducing tree densities and surface fuel loads, prescribed fires can be used to improve nutrient cycling, increase forage plant production, and improve wildlife habitat ([DeBano et al. 1998](https://books.google.com/books?id=cFxtriC2EDkC&lpg=PR15&ots=lzCwcsNMeg&dq=Fire's%20Effects%20on%20Ecosystems&lr&pg=PP1#v=onepage&q=Fire's%20Effects%20on%20Ecosystems&f=false); [Allen et al. 2002](https://esajournals.onlinelibrary.wiley.com/doi/abs/10.1890/1051-0761%282002%29012%5B1418%3AEROSPP%5D2.0.CO%3B2?casa_token=uFvw56TXOLsAAAAA%3A-zBtux0R_Ex4LLcEDpGZmcPs1vqygMErGnSS-DNWVYQkDC_Ti8eldbkhE4CkPXUwPmm5YO35gZI1axg)). 


```{r include=FALSE, echo=FALSE}
knitr::write_bib(c(
  .packages(),
  'bookdown'
  , 'knitr'
  , 'rmarkdown'
  , 'tidyverse'
  , 'lubridate'
  , 'RColorBrewer'
  , 'scales'
  , 'ggrepel'
  , 'viridis'
  , 'kableExtra'
  , 'sf'
  , 'stars'
  , 'lwgeom'
  , 'mapview'
  , 'leafpop'
  , 'lidR'
  , 'elevatr'
  , 'terra'
), 'packages.bib')
```

<!--chapter:end:index.Rmd-->

# Import Vector Data {#vector_data}

```{r, include=FALSE, warning=F, message=F}
# data mgmt
library(tidyverse)
library(lubridate)
# visualization
library(RColorBrewer)
library(scales)
library(ggrepel)
library(viridis)
library(kableExtra)
# spatial
library(sf)
library(lwgeom) 
library(mapview) #Interactive maps
library(leafpop) #map html popup

```

```{r, warning=F, message=F, results='hide'}
# turn off the s2 processing 
## https://stackoverflow.com/questions/68478179/how-to-resolve-spherical-geometry-failures-when-joining-spatial-data
sf::sf_use_s2(FALSE)
```

## National Forest Management data download

The Forest Activity Tracking System (FACTS) [database](https://data.fs.usda.gov/geodata/edw/datasets.php?xmlKeyword) maintained by the U.S. Department of Agriculture, Forest Service (USFS) used to delineate georeferenced boundaries of forest harvest activities.

```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6}
# check for data and download
zip_path <- c(
    "https://data.fs.usda.gov/geodata/edw/edw_resources/fc/S_USA.NFSLandUnit.gdb.zip"  # forests boundaries
    , "https://data.fs.usda.gov/geodata/edw/edw_resources/fc/S_USA.Experimental_Area_Boundaries.gdb.zip" # exp forest boundaries
    # , "https://data.fs.usda.gov/geodata/edw/edw_resources/fc/S_USA.Activity_TimberHarvest.gdb.zip" # Timber Harvests
    # , "https://data.fs.usda.gov/geodata/edw/edw_resources/shp/S_USA.Activity_HazFuelTrt_PL.zip" # Hazardous Fuel Treatment Reduction
    # , "https://data.fs.usda.gov/geodata/edw/edw_resources/shp/S_USA.Activity_SilvTSI.zip" # SilvTSI (Silviculture Timber Stand Improvement)
    # , "https://data.fs.usda.gov/geodata/edw/edw_resources/shp/S_USA.Activity_SilvReforestation.zip" # SilvReforestation
    # , "https://edcintl.cr.usgs.gov/downloads/sciweb1/shared/MTBS_Fire/data/composite_data/burned_area_extent_shapefile/mtbs_perimeter_data.zip"
    
  )
for (i in 1:length(zip_path)) {
  f_nm <- paste0( "../data/"
    , str_split(zip_path[i], "/", simplify = TRUE)[length(str_split(zip_path[i], "/", simplify = TRUE))]
  )
  fldr <- paste0(gsub(".zip", "", f_nm))
  options(timeout = 60 * 15)
  if(file.exists(fldr) == FALSE){
    # download data
    if(file.exists(f_nm) == FALSE){
      download.file(zip_path[i], destfile = f_nm)
    }else{print("file already exists")}
    # unzip
    unzip(f_nm, overwrite=TRUE, exdir = fldr)
    file.remove(f_nm)
  }else{print("unzip already exists")}
}
  
```

```{r, warning=F, message=F, echo=FALSE, include=FALSE}
remove(list = c("f_nm", "fldr", "zip_path"))
gc()
```

## Load Research Plot data

[Ritter et al. 2022](https://esajournals.onlinelibrary.wiley.com/doi/pdfdirect/10.1002/eap.2682) established eleven, 100x100 m (1-ha), plots within mechanical treatment units. Measurements occurred during the summer of 2017, which represented 3 years post-treatment for small group retention treatment and 4 years post-treatment for free selection-off, free selection-On, and commercial thinning treatments. In the free selection-off treatments, overstory trees were included in the spacing guidelines for precommercial thinning treatment. In the free selection-on treatments, overstory trees were not included in the spacing guidelines for precommercial thinning treatments resulting in residual precommercial trees potentially growing under the crown of an overstory tree. 

```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6}
# load shapefile
research_plots <- sf::st_read("../data/Black_Hills_StemMaps.shp") %>% 
  dplyr::filter(sf::st_is_valid(.)) %>% 
  rename_with(~ tolower(
    gsub(" ", "_", 
       str_trim(gsub("\\s+", " ", .x))
    )
  )) %>% 
  sf::st_buffer(dist = 50, endCapStyle = "SQUARE") %>% 
  dplyr::mutate(area = sf::st_area(.))

#rename sf geom column
  names(research_plots)[names(research_plots)==tolower(attr(research_plots, "sf_column"))] = "geometry"
  sf::st_geometry(research_plots) = "geometry"

# data structure of data
research_plots %>% glimpse()

# plot does not uniquely identify record
length(unique(research_plots$plot)) == nrow(research_plots)

# create id
  research_plots <- research_plots %>% 
    dplyr::group_by(plot) %>% 
    dplyr::mutate(
      plot_id = paste0(plot, "_", as.character(dplyr::row_number()))
    ) %>% 
    dplyr::ungroup() %>% 
    dplyr::relocate(plot_id)
  
  length(unique(research_plots$plot_id)) == nrow(research_plots)

```

## Load Stem Map data

[Ritter et al. 2022](https://esajournals.onlinelibrary.wiley.com/doi/pdfdirect/10.1002/eap.2682) installed three plots in the commercial thin treatment and each of the two free selection treatments. Only two plots were installed in the small group retention treatment as it was smaller in area and was bisected by a powerline corridor that precluded the placement of more than two nonoverlapping plots. Each plot was subdivided into 16 25x25 m quadrats within which all live trees >1.37 m tall had their x, y locations recorded. In addition to mapping their x, y location, all live trees were tagged and had their DBH, tree height (TH), compacted crown base height (CBH), crown width (CW), and species recorded.

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# load stem map shapefile
stem_map <- sf::st_read("../data/BHEF_stem_map.shp") %>% 
  dplyr::filter(sf::st_is_valid(.)) %>% 
  rename_with(~ tolower(
    gsub(" ", "_", 
       str_trim(gsub("\\s+", " ", .x))
    )
  )) %>% 
  sf::st_transform(crs = sf::st_crs(research_plots))

#rename sf geom column
  names(stem_map)[names(stem_map)==tolower(attr(stem_map, "sf_column"))] = "geometry"
  sf::st_geometry(stem_map) = "geometry"

# data structure of stem map data
stem_map %>% glimpse()
```

## Load Rx Fire shapefile

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# load stem map shapefile
rx_fire <- sf::st_read("../data/ExpoRX.shp") %>% 
  dplyr::filter(sf::st_is_valid(.)) %>% 
  rename_with(~ tolower(
    gsub(" ", "_", 
       str_trim(gsub("\\s+", " ", .x))
    )
  )) %>% 
  sf::st_transform(crs = sf::st_crs(research_plots))

#rename sf geom column
  names(rx_fire)[names(rx_fire)==tolower(attr(rx_fire, "sf_column"))] = "geometry"
  sf::st_geometry(rx_fire) = "geometry"

# data structure of stem map data
rx_fire %>% glimpse()
```

## Load National Forests shapefile

```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6}
# load forest boundary shapefile
  # extract file name
    f_path <- paste0("../data", "/", "S_USA.NFSLandUnit.gdb", "/")
    dta_nm <- paste(f_path
      , list.files(f_path, pattern = "\\.gdb$")[1]
      , sep = "/"
    )
    lyr_nms <- sf::st_layers(dsn = dta_nm)$name
    lyr <- lyr_nms[grep("NFSLandUnit", lyr_nms)][1]
  # load in data
    forests <- sf::st_read(
        dsn = dta_nm
        , layer = lyr
        , query = "SELECT * FROM \"NFSLandUnit\" 
                WHERE 
                  REGION NOT IN ('08', '09', '10')
                  AND NFSLANDUNITTYPE = 'National Forest'
            "
      ) %>% 
      rename_with(~ tolower(
        gsub(" ", "_", 
           str_trim(gsub("\\s+", " ", .x))
        )
      ))
    
  #rename sf geom column
    names(forests)[names(forests)==tolower(attr(forests, "sf_column"))] = "geometry"
    sf::st_geometry(forests) = "geometry"
    
  # transform
    forests <- forests %>% 
      sf::st_transform(crs = sf::st_crs(research_plots))

  #make BHNF only dataset
    forests_bhnf <- forests %>% filter(region == "02" & nffid == "0471")

  
```

## Load Experimental Forests shapefile

```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6}
# load boundary shapefile
  # extract file name
    f_path <- paste0("../data", "/", "S_USA.Experimental_Area_Boundaries.gdb", "/")
    dta_nm <- paste(f_path
      , list.files(f_path, pattern = "\\.gdb$")[1]
      , sep = "/"
    )
    lyr_nms <- sf::st_layers(dsn = dta_nm)$name
    lyr <- lyr_nms[grep("Experimental_Area_Boundaries", lyr_nms)][1]
  # load in data
    exp_forests <- sf::st_read(
        dsn = dta_nm
        , layer = lyr
      ) %>%
      rename_with(~ tolower(
        gsub(" ", "_",
           str_trim(gsub("\\s+", " ", .x))
        )
      ))
    
  #rename sf geom column
    names(exp_forests)[names(exp_forests)==tolower(attr(exp_forests, "sf_column"))] = "geometry"
    sf::st_geometry(exp_forests) = "geometry"
  
  # transform
    exp_forests <- exp_forests %>% 
      sf::st_transform(crs = sf::st_crs(research_plots))
    
  # spatial join BHNF
    bhef_boundary <- sf::st_intersection(forests_bhnf %>% dplyr::select(nfslandunitid, nffid, nfslandunitname), exp_forests)

  
```

## Load FACTS Timber Harvests {#harvests}

Metadata file available [here](https://data.fs.usda.gov/geodata/edw/edw_resources/meta/S_USA.Activity_TimberHarvest.xml). 

*Utilize data downloaded and created in Forest Management Impacts on Productivity [project](https://github.com/georgewoolsey/harvest_npp).* 

[This appendix](https://www.fs.usda.gov/Internet/FSE_DOCUMENTS/fseprd539041.pdf) includes a listing of all the active and inactive FACTS activity codes, as well as detailed descriptions of some of the codes.

```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6}
# load boundary shapefile
    harvests <- sf::st_read("../data/harvests.gpkg") %>%
      rename_with(~ tolower(
        gsub(" ", "_",
           str_trim(gsub("\\s+", " ", .x))
        )
      ))
    
  #rename sf geom column
    names(harvests)[names(harvests)==tolower(attr(harvests, "sf_column"))] = "geometry"
    sf::st_geometry(harvests) = "geometry"
  
  # transform
    harvests <- harvests %>% 
      sf::st_transform(crs = sf::st_crs(research_plots))
    
  # spatial join BHEF
    # bhef_harvests <- sf::st_intersection(
    #     bhef_boundary %>% 
    #        dplyr::select(name, station, hectares, lead_scientist) %>% 
    #        dplyr::rename_with(~ paste0("exp_forest_", .), -geometry) %>% 
    #       # there are some plots outside of BHEF boundary
    #       sf::st_buffer(2500)
    #     , harvests)
    bhef_harvests <- sf::st_intersection(
      # there are some plots outside of BHEF boundary
        sf::st_union(
            bhef_boundary
            , sf::st_as_sfc(sf::st_bbox(research_plots)) %>% 
                sf::st_transform(crs = sf::st_crs(research_plots)) 
        ) %>% dplyr::select(geometry)
        , harvests)
    

  
# filter for last 15 years
bhef_harvests_l15 <- bhef_harvests %>% dplyr::filter(year_id >= year(Sys.time()) - 15 ) %>% 
  dplyr::mutate(lab <- paste0(treatment_type_grp, " (", as.character(year_id), ")"))

```

### Harvests by treatment type

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# data by treatment type
bhef_harvests_l15 %>% sf::st_set_geometry(NULL) %>% 
  dplyr::group_by(activity_name) %>% 
  dplyr::summarise(n = n()) %>% 
  dplyr::arrange(desc(n)) %>% 
ggplot(.) +
  geom_col(aes(y = reorder(activity_name, n), x = n, fill = n), width = 0.7) +
  geom_text(
    aes(y = reorder(activity_name, n), x =n, label = scales::comma(n, accuracy = 1))
    , color = "black", size = 4
    , position = position_dodge(0.9)
    , hjust = -0.1
  ) +
  labs(
      title = "Number Harvests Completed by Treatment Type (last 15 years)"
      , subtitle = "within BHEF boundary and bounding box of research plot area"
    ) +
  xlab("# Harvests") +
  ylab("Treatment") +
  scale_x_continuous(labels = scales::comma) +
  scale_fill_viridis_c(alpha = 0.7, option = "cividis", direction = -1) +
  theme_bw() +
  theme(
    legend.position = "none"
  )
```

```{r, warning=F, message=F, echo=FALSE, include=FALSE}
gc()
```

## Join Research Plot to Harvest

```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6}
# attach harvest data to research plots
research_plots_harvests <- sf::st_intersection(
  research_plots
  , bhef_harvests_l15 %>% 
      dplyr::select(
        activity_code
        , activity_name
        , treatment_type_grp
        , suid
        , date_compl
        , year_id
      ) %>% 
      # dplyr::filter(treatment_type_grp %in% c("Commercial Thinning"
      #                                         , "Overstory Removal Cut"
      #                                         , "Single-tree/Group Selection Cut"
      #                                         , "Patch Clearcut"
      #       )) %>% 
      dplyr::rename_with(~ paste0("harvest_", .), -geometry)
  ) %>% 
  dplyr::mutate(harvest_plot_areamsq = as.numeric(sf::st_area(.))) %>% 
  sf::st_set_geometry(NULL) %>% 
  dplyr::group_by(plot_id) %>% 
  dplyr::arrange(
    plot_id
    , desc(harvest_plot_areamsq)
    , harvest_date_compl
  ) %>% 
  dplyr::select(
    plot_id
    , dplyr::starts_with("harvest_")
  ) %>% 
  dplyr::mutate(
    row_n = dplyr::row_number()
  ) %>% 
  dplyr::ungroup() %>% 
  tidyr::pivot_wider(
    id_cols = plot_id
    , names_from = row_n
    , values_from = !c(plot_id, row_n)
    , names_sep = "_"
  )

# join to spatial data
research_plots <- research_plots %>% 
  left_join(research_plots_harvests, by = c("plot_id"="plot_id"))

remove(research_plots_harvests)

```

## Join Stem Map to Research Plot & Harvest

```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6}
# attach harvest data to stem map
stem_map_harvests <- sf::st_intersection(
  stem_map
  , bhef_harvests_l15 %>% 
      dplyr::select(
        activity_code
        , activity_name
        , treatment_type_grp
        , suid
        , date_compl
        , year_id
      ) %>% 
      dplyr::rename_with(~ paste0("harvest_", .), -geometry)
  ) %>% 
  sf::st_set_geometry(NULL) %>% 
  dplyr::group_by(uidtree) %>% 
  dplyr::arrange(
    uidtree
    , harvest_date_compl
  ) %>% 
  dplyr::select(
    uidtree
    , dplyr::starts_with("harvest_")
  ) %>% 
  dplyr::mutate(
    row_n = dplyr::row_number()
  ) %>% 
  dplyr::ungroup() %>% 
  tidyr::pivot_wider(
    id_cols = uidtree
    , names_from = row_n
    , values_from = !c(uidtree, row_n)
    , names_sep = "_"
  )

# join to spatial data
stem_map <- stem_map %>% 
  left_join(stem_map_harvests, by = c("uidtree"="uidtree"))

# join to research plot data
temp_stem_map <- sf::st_intersection(
    stem_map %>% dplyr::select(uidtree)
    , research_plots %>% 
        dplyr::select(plot_id, trt, harvest_activity_name_1, harvest_year_id_1, harvest_treatment_type_grp_1) %>% 
        dplyr::rename_with(~ paste0("rplot_", .), -geometry)
  ) %>% 
  sf::st_set_geometry(NULL)

stem_map <- stem_map %>% 
  left_join(temp_stem_map, by = c("uidtree"="uidtree"))

remove(list = c("stem_map_harvests", "temp_stem_map"))
```

```{r, warning=F, message=F, echo=FALSE, include=FALSE}
gc()
```

### Stem Map Descriptive statistics.

```{r, warning=F, message=F, fig.width = 12, fig.height = 6}
# descriptive stats
kable(stem_map %>% sf::st_set_geometry(NULL) %>% 
        dplyr::group_by(
          unit
          , harvest_activity_name_1
        ) %>% 
        dplyr::summarise(
          # plots = dplyr::n_distinct(plot)
          trees = dplyr::n_distinct(uidtree)
          , min_DBHin = min(dbhin)
          , max_DBHin = max(dbhin)
          , mean_DBHin = mean(dbhin)
          , QMDin = sqrt( sum(dbhin*dbhin) / n() )
          , min_HTft = min(heightft)
          , max_HTft = max(heightft)
          , mean_HTft = mean(heightft)
          , stdev_HTft = sd(heightft)
        ) %>% 
    dplyr::arrange(unit, desc(trees)) 
  , format = "html" 
  , caption = "Tree Measurement Descriptive Statistics by Unit & Treatment"
  , digits = 1
  , col.names = c(
    "unit"
    , "treatment"
    # , "# plots"
    , "# trees"
    , "min"
    , "max"
    , "mean"
    , "QMD"
    , "min"
    , "max"
    , "mean"
      , "st.dev."
  )
  , align=rep('c', 5)
) %>% 
# kable_classic() %>%
add_header_above(c(" " = 3, "DBH (in.)" = 3, "QMD (in.)" = 1, "Height (ft.)" = 4)) %>% 
kable_material(c("striped", "hover")) %>%
kable_styling(font_size = 9) %>% 
column_spec(1, bold = TRUE, width = "1em")


```

## Map Harvests, Research Plots, Stem Map

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# make map
# different background map types: https://leaflet-extras.github.io/leaflet-providers/preview/
# names(leaflet.providers::providers_loaded()$providers)
mapviewOptions(homebutton = FALSE, basemaps = c("Esri"))
# map
mapview(bhef_boundary
        , color = "black"
        , lwd = 3
        , alpha.regions = 0
        , label = FALSE
        , legend = FALSE
        , popup = FALSE
) +
mapview(bhef_harvests_l15
        , zcol = "treatment_type_grp"
        , col.regions = viridis::viridis(n=length(unique(bhef_harvests_l15$treatment_type_grp)))
        , alpha.regions = 0.6
        , label = c("lab")
        , legend = FALSE
          , popup = popupTable(
              bhef_harvests_l15
              , zcol = c(
                "year_id"
                , "treatment_type_grp"
                , "activity_name"
              )
              , row.numbers = FALSE
              , feature.id = FALSE
            )
) +
mapview(rx_fire
        , color = "red"
        , lwd = 2
        , alpha.regions = 0
        , label = FALSE
        , legend = FALSE
        , popup = FALSE
) +
mapview(research_plots
        , zcol = "trt"
        , col.regions = viridis::mako(n=length(unique(research_plots$trt)), direction = -1)
        , lwd = 2
        , col = "gray90"
        , alpha.regions = 0.8
        , label = c("trt")
        , legend = FALSE
          , popup = popupTable(
              research_plots
              , zcol = c(
                "plot"
                , "trt"
                , "harvest_activity_name_1"
                , "harvest_year_id_1"
              )
              , row.numbers = FALSE
              , feature.id = FALSE
            )
)  +
mapview(stem_map
  , zcol = "unit"
  , col.regions = viridis::turbo(n=length(unique(stem_map$unit)), alpha = 0.8)
    # RColorBrewer::brewer.pal(n = length(unique(stem_map$unit)), name = "RdYlBu")
  , cex = 3.5
  , label = c("unit")
  , legend = FALSE
    , popup = popupTable(
        stem_map
        , zcol = c(
          "unit"
          , "plot"
          , "species"
          , "tag"
          , "heightft"
          , "dbhin"
          , "harvest_activity_name_1"
          , "harvest_year_id_1"
        )
        , row.numbers = FALSE
        , feature.id = FALSE
      )
)

```

*Note, only harvests in last 15 years shown*

## Write Out Data

```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6}
# save cleaned data for reading to R later
sf::st_write(forests_bhnf, "../data/forests_bhnf.gpkg", append = FALSE)
sf::st_write(bhef_boundary, "../data/bhef_boundary.gpkg", append = FALSE)
sf::st_write(bhef_harvests, "../data/bhef_harvests.gpkg", append = FALSE)
sf::st_write(research_plots, "../data/research_plots.gpkg", append = FALSE)
sf::st_write(stem_map, "../data/stem_map.gpkg", append = FALSE)
sf::st_write(rx_fire, "../data/rx_fire.gpkg", append = FALSE)
```

<!--chapter:end:01_data_processing_spatial.Rmd-->

# Analyze Lidar Data {#lidar_data}

```{r, include=FALSE, warning=F, message=F}
# data mgmt
library(tidyverse)
library(lubridate)
# visualization
library(RColorBrewer)
library(scales)
library(ggrepel)
library(viridis)
library(kableExtra)
# spatial
library(sf)
library(stars)
library(lwgeom) 
library(mapview) #Interactive maps
library(leafpop) #map html popup
library(lidR) # lidar data
library(elevatr) # elevation data (DEMs)
library(terra) # raster math
# library(spatstat) #point pattern analysis
```

```{r, warning=F, message=F, results='hide'}
# turn off the s2 processing 
## https://stackoverflow.com/questions/68478179/how-to-resolve-spherical-geometry-failures-when-joining-spatial-data
sf::sf_use_s2(FALSE)
```

## Overwrite Data Switch

```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6}
#######################################################
#######################################################
# TURN ON/OFF DATA OVERWRITE
# TURNING THIS ON WILL RE-RUN ALL LIDAR PROCESSING
# WHICH TAKES A LONG TIME
#######################################################
#######################################################
overwrite_it <- FALSE
```

## Download Data From Nat'l Map

The [USGS National Map](https://apps.nationalmap.gov/downloader/) was used to obtain a list of file download links for "Elevation Source Data (3DEP) - Lidar, IfSAR" data available marked as "Lidar Point Cloud (LPC)". This download file list was placed in the `data` folder where the code below utilizes it to download data. The "thumbnail" option in the Nat'l Map was used to determine that the "Fugro" data will suffice to cover the BHEF area. Also, downloaded NAIP imagery and 3dep elevation while had ROI drawn in Nat'l Map.

```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6}
#######################################################
#######################################################
# download lidar data
#######################################################
#######################################################
# open download text file
urls <- read.delim("../data/usgs_lidar_data.txt", header = FALSE) %>% 
  dplyr::rename(url_path = 1) %>% 
  dplyr::filter(grepl("FUGRO", toupper(url_path)) == TRUE) %>%
  dplyr::mutate(
    orig_fname = word(gsub("/", " ", url_path), -1)
    , fname_sans_typ = gsub(".laz", "", orig_fname)
  )


# create parent directory for data
  hey_dir <- "../data/lidar/"
  if(dir.exists(hey_dir)==FALSE){
    dir.create(hey_dir)
  }
#loop through to download lidar data
  for(i in 1:nrow(urls)){
    # set up names
    f_nm <- paste0(hey_dir
      , urls$orig_fname[i]
    )
    options(timeout = 60 * 15)
    ########################
    ## download and unzip
    ########################
    if(file.exists(f_nm)==FALSE){
      # download
      download.file(urls$url_path[i], destfile = f_nm)
    }else{
      print(paste0(f_nm, " file already exists"))
    }
  }
#######################################################
#######################################################
# download elevation data
#######################################################
#######################################################
  # open download text file
  urls <- read.delim("../data/usgs_dem_data.txt", header = FALSE) %>% 
    dplyr::rename(url_path = 1) %>% 
    dplyr::filter(grepl("FUGRO", toupper(url_path)) == TRUE) %>%
    dplyr::mutate(
      orig_fname = word(gsub("/", " ", url_path), -1)
      , fname_sans_typ = gsub(".laz", "", orig_fname)
    )
  
  
  # create parent directory for data
    hey_dir <- "../data/dem/"
    if(dir.exists(hey_dir)==FALSE){
      dir.create(hey_dir)
    }
  #loop through to download dem data
    for(i in 1:nrow(urls)){
      # set up names
      f_nm <- paste0(hey_dir
        , urls$orig_fname[i]
      )
      options(timeout = 60 * 15)
      ########################
      ## download and unzip
      ########################
      if(file.exists(f_nm)==FALSE){
        # download
        download.file(urls$url_path[i], destfile = f_nm)
      }else{
        print(paste0(f_nm, " file already exists"))
      }
    }

```

## Load Vector Data

Spatial data was loaded and cleaned in [prior chapter](#vector_data). 

```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6}
# read
forests_bhnf <- sf::st_read("../data/forests_bhnf.gpkg")
bhef_boundary <- sf::st_read("../data/bhef_boundary.gpkg")
bhef_harvests <- sf::st_read("../data/bhef_harvests.gpkg")
research_plots <- sf::st_read("../data/research_plots.gpkg")
stem_map <- sf::st_read("../data/stem_map.gpkg")
rx_fire <- sf::st_read("../data/rx_fire.gpkg")
if(file.exists("../data/crowns_group.gpkg") == TRUE & overwrite_it == FALSE){
  crowns_group <- sf::st_read("../data/crowns_group.gpkg")
}
if(file.exists("../data/tree_tops.gpkg") == TRUE & overwrite_it == FALSE){
  tree_tops <- sf::st_read("../data/tree_tops.gpkg")
}
if(file.exists("../data/chm.tif") == TRUE & overwrite_it == FALSE){
  chm <- stars::read_stars("../data/chm.tif")
}

```

## Load Elevation Data

The [USGS National Map](https://apps.nationalmap.gov/downloader/) was used to obtain a list of file download links for "Elevation Source Data (3DEP)" data. Using `elevatr::get_elev_raster` to get a digital elevation model (DEM) raster (~6.8m resolution) as a backup.

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
#######################################################
#######################################################
# read elevation data
#######################################################
#######################################################
  if(file.exists("../data/bhef_elev.tif") == FALSE){
    #######################################################
    # 1 m dem
    #######################################################
      # tifs <- list.files("../data/dem/", pattern = "\\.tif$", full.names = TRUE)
      # 
      # newgrid <- bhef_boundary %>%
      #   sf::st_buffer(dist = 10000) %>% 
      #   sf::st_bbox() %>%
      #   stars::st_as_stars(dx = 1, dy = 1)
      #   # stars::st_as_stars()
      #   
      # # read files
      # for(i in 1:length(tifs)){
      #   f_nm <- paste0("elev_", i)
      #   assign(f_nm,
      #         stars::read_stars(tifs[i]) %>% 
      #           stars::st_warp(newgrid) %>% 
      #           setNames("elev")
      #           # sf::st_transform(crs = sf::st_crs(bhef_boundary))
      #   )
      # }
      # # mosaic together !!!!!!!!!!!!!!! NEED TO REMOVE HARD-CODING OF OBJECT NAMES
      # elev <- stars::st_mosaic(elev_1, elev_2, elev_3, elev_4)
      # remove(list = ls(pattern = "elev_") )
      # bhef_elev <- elev[sf::st_buffer(bhef_boundary %>% dplyr::select(name), dist = 1000)]
    #######################################################
    # not 1 m dem
    #######################################################
      # z =14 is highest resolution (~6.8m)
      elev <- elevatr::get_elev_raster(bhef_boundary, z = 14)
      # sf::st_crs(elev) == sf::st_crs(bhef_boundary)
      bhef_elev <- stars::st_as_stars(elev)
        # sf::st_transform(crs = sf::st_crs(bhef_boundary))
      # save
    stars::write_stars(bhef_elev, "../data/bhef_elev.tif", append = FALSE)
  }else{
    bhef_elev <- stars::read_stars("../data/bhef_elev.tif")
  }
```

### Elevation plot

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# plot
ggplot() + stars::geom_stars(data = bhef_elev[bhef_boundary]) +
  scale_fill_viridis_c(option = "viridis", alpha = 0.9, na.value = "transparent") +
  geom_sf(data = bhef_boundary, alpha = 0, lwd = 1, color = "black", linetype = "dashed") +
  labs(
      title = "BHEF Elevation Map"
      , subtitle = sf::st_crs(bhef_elev)$input
    ) +
  xlab("") +
  ylab("") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_bw() +
  theme(
    axis.text = element_text(size = 8)
    # , panel.grid = element_blank()
    , panel.border = element_blank()
  ) +
  guides(
    fill = guide_legend(title="Elev. (m)")
  )

```

```{r, warning=F, message=F, echo=FALSE, include=FALSE}
remove(list = c("urls", "elev", "f_nm", "hey_dir", "tifs", "r", "x"))
gc()
```

## Lidar Data Processing

Use the `lidR` package for manipulating and visualizing point cloud data. See the very [helpful book](https://r-lidar.github.io/lidRbook/index.html) by Roussel, J.R., Goodbody, T.R.H., and Tompalski P. (2021) for more information.

```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6}
if(file.exists("../data/crowns_group.gpkg") == TRUE & overwrite_it == FALSE){
  print("Proceeding to next section without processing or overwriting data...")
}else{
# list laz files
  lazs <- sort(list.files("../data/lidar/", pattern = "\\.laz$", full.names = TRUE), decreasing = FALSE)
# change projection of DEM 
  # # creating a new regular grid in a new CRS
  # newgrid <- bhef_boundary %>% 
  #   sf::st_transform(crs = sf::st_crs( lidR::readLAS(lazs[1], select = "xyz") )) %>% 
  #   sf::st_bbox() %>%
  #   stars::st_as_stars()
  # # set up old grid to warp back
  # oldgrid <- bhef_boundary %>% 
  #   sf::st_bbox() %>%
  #   stars::st_as_stars()
  # # warping the old raster to the new grid
  # bhef_elev_reproj <- bhef_elev %>%
  #   stars::st_warp(newgrid)
  
  # bhef_elev_reproj <- bhef_elev %>% stars::st_warp(crs = sf::st_crs( lidR::readLAS(lazs[1], select = "xyz") ))
######################################################
# read laz files
######################################################
  # If several files are read at once the returned LAS object is considered as one LAS file.
  # las <- lidR::readLAS(lazs[2], select = "xyz") %>% # load XYZ only
  las <- lidR::readLAS(lazs, select = "xyz") %>% 
     sf::st_transform(crs = sf::st_crs(bhef_elev))
  # lidR::las_check(las)
  # remove duplicate points
  las <- lidR::filter_duplicates(las)
  # lidR::las_check(las)
  # summary(las$Z)
  # sf::st_crs(las)
  # temp_plot <- plot(las, color = "Z", breaks = "quantile", bg = "white")
  # temp_plot
  # # add_treetops3d(temp_plot, tree_tops)
######################################################
# remove outliers
######################################################
  # Use Statistical Outliers Removal (SOR)
    # k = number of neighbors
    # m = multiplier in : avg distance + m * std deviation
    las <- lidR::classify_noise(las, sor(k = 15, m = 7))
    # plot(las, color = "Classification", bg = "white", size = 3)
  # Remove outliers using filter_poi()
    las <- lidR::filter_poi(las, Classification != LASNOISE)
    # plot(las, color = "Z", breaks = "quantile", bg = "white")
  # #repeat process with Isolated Voxels Filter IVF
  #   las <- lidR::classify_noise(las, ivf(res = 5, n = 6))
  #   # plot(las, color = "Classification", bg = "white", size = 3)
  # # Remove outliers using lidR::filter_poi()
  #   las <- lidR::filter_poi(las, Classification != LASNOISE)
    # plot(las, color = "Z", breaks = "quantile", bg = "white")
# #####################################################
# Ground classification
# !!!!!!!!!!!!!!!!!!!!!!!!!! This is computationally intensive :'(
# #####################################################
# ##################################################
# Progressive Morphological Filter The implementation of PMF algorithm in lidR
# is based on the method described in Zhang et al. (2003)
# ##################################################
# # # b numeric. This is the parameter b in Zhang et al. (2003) (eq. 4 and 5).
# # # dh0 numeric. This is dh0 in Zhang et al. (2003) (eq. 7).
# # # dhmax numeric. This is dhmax in Zhang et al. (2003) (eq. 7).
# # # s numeric. This is s in Zhang et al. (2003) (eq. 7).
# # # max_ws numeric. Maximum window size to be used in filtering ground returns. This
# # # limits the number of windows created.
# # # exp logical. The window size can be increased linearly or exponentially (eq. 4 or 5).
# # lidR::util_makeZhangParam(
# #   b = 2,
# #   dh0 = 0.2,
# #   dhmax = 210,
# #   s = 1.2,
# #   max_ws = 20,
# #   exp = FALSE
# # )
# las <- lidR::classify_ground(las, algorithm = pmf(
#   ws = lidR::util_makeZhangParam()$ws
#   , th = lidR::util_makeZhangParam()$th
#   )
# )
}
```

### Height normalization using DEM 

Height normalization using the DEM loaded above subtacts the height of the ground surface from the point cloud at the resolution of the DEM raster data. The resulting normalized point cloud data classifies ground points at 0 meter in height (Z) and all points  >0 meters in height is assumed to be non-ground surface cover.

```{r, warning=F, message=F, fig.width = 12, fig.height = 6, results='hide'}
if(file.exists("../data/crowns_group.gpkg") == TRUE & overwrite_it == FALSE){
  print("Proceeding to next section without processing or overwriting data...")
}else{
######################################################
# Height normalization using DEM 
    # could create own DEM with lidar data ... 
    # but will use out of the box product for now
######################################################
  # subtract DEM from lidar returns
    nlas <- las - bhef_elev
  # correct for below ground returns
    nlas@data$Z <- ifelse(
        ceiling(nlas@data$Z) == 0 
        | floor(nlas@data$Z) == 0
        | nlas@data$Z <= 0
      , 0, nlas@data$Z
    )
    # nlas <- filter_poi(nlas, Z >= 0) # remove below ground points
    nlas@data$Z <- ifelse(nlas@data$Z <= 0, 0, nlas@data$Z)
  # update classification
    nlas@data$Classification <- ifelse(nlas@data$Z==0, 2, nlas@data$Classification)
  # filter out top 0.2% heights
    nlas <- filter_poi(nlas, Z <= stats::quantile((nlas@data %>% dplyr::filter(Classification==1))$Z, 0.998))
    # plot(nlas, color = "Z", breaks = "pretty", bg = "white")
    # summary(nlas$Z)
    # table(nlas$Classification)
# ######################################################
# # Height normalization using point cloud interpolation
# # !!!!!! must run ground classification above first
# ######################################################
#   # point cloud normalization using interpolation
#     nlas <- normalize_height(las, knnidw())
#     # plot(nlas, color = "Z", breaks = "pretty", bg = "white")
#     # plot(lidR::filter_ground(nlas), color = "Classification", bg = "white")
#     # summary(nlas$Z)
#     # table(nlas$Classification)
    
######################################################
# descriptive stats
######################################################
kable(nlas@data %>% 
        dplyr::group_by(
          Classification
        ) %>% 
        dplyr::summarise(
          # plots = dplyr::n_distinct(plot)
          points = dplyr::n()
          , min_z = min(Z)
          , max_z = max(Z)
          , mean_z = mean(Z)
          , median_z = median(Z)
          , stdev_z = sd(Z)
        ) %>% 
    dplyr::arrange(Classification) %>% 
    dplyr::mutate(
      Classification = dplyr::case_when(
        Classification == 1 ~ "Surface"
        , Classification == 2 ~ "Ground"
        , TRUE ~ "Other"
      )
    )
  , format = "html" 
  , caption = "Point Cloud Summary Statistics for Return Height (Z)"
  , digits = 1
  , col.names = c(
    "Classification"
    , "points"
    , "min"
    , "max"
    , "mean"
    , "median"
    , "st.dev."
  )
  , align=rep('c', 5)
) %>% 
# kable_classic() %>%
add_header_above(c(" " = 2, "Point Return Height (m)" = 5)) %>% 
kable_material(c("striped", "hover")) %>%
# column_spec(., 2, width = "20em") %>% 
kable_styling(font_size = 11) 
    
# ggplot() + geom_histogram(data = (nlas@data %>% dplyr::filter(Classification == 1)), aes(Z), binwidth = 1)

}
```


### Canopy Height model

Points-to-raster algorithm with a resolution of 1 meter. For each pixel of the output raster the function attributes the height of the highest point found in the pixel from the point cloud.

```{r, warning=F, message=F, fig.width = 10, fig.height = 6, results='hide'}
if(file.exists("../data/crowns_group.gpkg") == TRUE & overwrite_it == FALSE){
  print("Proceeding to next section without processing or overwriting data...")
}else{
######################################################
# Canopy Height model
######################################################
  # Points-to-raster algorithm with a resolution of 1 meter
    chm <- lidR::rasterize_canopy(
      nlas
      , res = 1
      #  for each pixel of the output raster the function attributes the height of the highest point found
      , p2r(subcircle = 0.0
            # , na.fill = tin()
            , na.fill = knnidw(
              k = 10
              , p = 2
              , rmax = 5
            )
        )
      , pkg = "terra"
    ) 
    
    # smooth chm pixels with median value in 3x3 matrix
    kernel <- matrix(1,3,3)
    chm_smooth <- terra::focal(chm, w = kernel, fun = median, na.rm = TRUE) %>% 
      stars::st_as_stars()
      # stars::st_warp(crs = sf::st_crs(bhef_boundary)) 
    # %>% 
    #   sf::st_transform(crs = sf::st_crs(bhef_boundary))
    # non smoothed
    chm <- chm %>% 
      stars::st_as_stars()
      # stars::st_warp(crs = sf::st_crs(bhef_boundary))
}
```

#### CHM plot

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
  # plot
  ggplot() +
    stars::geom_stars(data = chm[rx_fire %>% dplyr::slice_head(n = 1)]) +
    # geom_sf(data = sf::st_crop(bhef_boundary, sf::st_bbox(chm_smooth)), alpha = 0, lwd = 0) +
    geom_sf(data = rx_fire %>% dplyr::slice_head(n = 1), alpha = 0, lwd = 1, color = "orangered") +
    scale_fill_viridis_c(option = "mako", alpha = 0.9, na.value = "transparent") +
    labs(
      title = "BHEF Canopy Height Model"
      , subtitle = paste0("sample Rx fire unit (", sf::st_crs(chm)$input, ")")
    ) +
    xlab("") +
    ylab("") +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    theme_bw() +
    theme(
      # legend.position = "bottom"
      # , legend.direction = "horizontal"
      axis.text = element_text(size = 8)
      # , panel.grid = element_blank()
      , panel.border = element_blank()
    ) +
    guides(
      fill = guide_legend(title="Hgt. (m)")
    )
```

### Individual Tree Detection (ITD)

Local maximum filtering (LMF) with variable window size. Points below 2 m will equate to a window size of 3 m, while points above 20 meters equate to a window size of 5 m. Anything between 2 and 20 meter will have a non-linear relationship.

```{r, warning=F, message=F, fig.width = 10, fig.height = 6, results='hide'}
if(file.exists("../data/crowns_group.gpkg") == TRUE & overwrite_it == FALSE){
  print("Proceeding to next section without processing or overwriting data...")
}else{
######################################################
# Individual Tree Detection (ITD)
######################################################
# local maximum filtering (LMF) with variable window size
  # points below 2 m will equate to a window size of 3 m, 
    # while points above 20 meters equate to a window size of 5 m. 
    # Anything between 2 and 20 meter will have a non-linear relationship
  # define variable window function
  ws_fn <- function(x) {
      y <- 2.6 * (-(exp(-0.08*(x-2)) - 1)) + 3
      y[x < 2] <- 3
      y[x > 20] <- 5
      return(y)
  }
  # ITD on CHM
  tree_tops <- lidR::locate_trees(chm_smooth, lmf(ws = ws_fn)) %>% 
    # create classes based on Steel et al. 2021
    dplyr::mutate(
      tree_class = dplyr::case_when(
        Z > 8 ~ 3 # canopy
        , Z >= 2 ~ 2 # subcanopy
        , Z >= 1 ~ 1 # understory
        , TRUE ~ 0 # ground
      )
    )
}
```

#### Tree Tops plot

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
  # plot
  ggplot() +
    stars::geom_stars(data = chm[rx_fire %>% dplyr::slice_head(n = 1)]) +
    geom_sf(data = rx_fire %>% dplyr::slice_head(n = 1), alpha = 0, lwd = 1, color = "orangered") +
    geom_sf(data = sf::st_intersection(tree_tops, rx_fire %>% dplyr::slice_head(n = 1))
            , color = viridis::viridis(n=1, direction = -1), alpha = 0.7, shape = "."
    ) +
    scale_fill_viridis_c(option = "mako", alpha = 0.9, na.value = "transparent") +
    labs(
      title = "BHEF Canopy Height Model with Tree Tops Identified (yellow)"
      , subtitle = paste0("sample Rx fire unit (", sf::st_crs(chm)$input, ")")
    ) +
    xlab("") +
    ylab("") +
    theme_bw() +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    theme(
      axis.text = element_text(size = 8)
      # , panel.grid = element_blank()
      , panel.border = element_blank()
    ) +
    guides(
      fill = guide_legend(title="Hgt. (m)")
    )
  
  # hey_plot <- plot(nlas, color = "Z", breaks = "pretty", bg = "white")
  # add_treetops3d(hey_plot, tree_tops <- lidR::locate_trees(chm_smooth, lmf(ws = ws_fn)), col = "black")
  # ?lidR::pixel_metrics()
```

#### Distribution of Tree Top Heights

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
######################################################
# height range of tree tops
######################################################
tree_tops %>% sf::st_set_geometry(NULL) %>% 
  dplyr::mutate(height_ceil = ceiling(Z)) %>% 
  dplyr::group_by(height_ceil) %>% 
  dplyr::summarise(n = n()) %>% 
  dplyr::ungroup() %>% 
  dplyr::mutate(
    pct_tot = n / sum(n)
  ) %>% 
  ggplot(.) +
    # geom_col(aes(x = height_ceil, y = n, fill = n)) +
    geom_bar(aes(x = height_ceil, y = pct_tot, fill = n), color = "gray25", stat = "identity") +
    scale_y_continuous(labels = scales::label_percent(accuracy = 1L)) +
    scale_x_continuous(breaks = seq(min(tree_tops$Z), max(tree_tops$Z)+1, 1))+
    scale_fill_viridis_c(alpha = 0.9, option = "mako", direction = -1) +
    labs(
        title = "Distribution of Tree Top Heights (m)"
      ) +
    xlab("Tree Height (m) Bin") +
    ylab("% Tree tops") +
    theme_bw() +
    theme(
      legend.position="none"
    ) 
```

```{r, warning=F, message=F, echo=FALSE, include=FALSE}
gc()
```

### Individual Tree Crown (ITC) Segmentation

Segment the canopy height model raster grid as individual tree crowns (ITC). Following the seeds + growing region algorithm described by [Dalponte and Coomes (2016)](https://besjournals.onlinelibrary.wiley.com/doi/pdf/10.1111/2041-210X.12575) to create a vector representation of tree crowns. Then using the individual tree crowns to create groupings and summary statistics of height for each interconnected crown group.


```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6, results='hide'}
if(file.exists("../data/crowns_group.gpkg") == TRUE & overwrite_it == FALSE){
  print("Proceeding to next section without processing or overwriting data...")
}else{
######################################################
# Individual Tree Segmentation (ITS)
######################################################
# implements an algorithm for tree segmentation based on 
  # Dalponte and Coomes (2016) algorithm (see reference). 
  # This is a seeds + growing region algorithm.
  algo <- lidR::dalponte2016(
    chm = chm 
    , treetops = tree_tops
    # Threshold below which a pixel cannot be a tree
    , th_tree = 2 
    # Pixel is added to a region if its height is greater than the tree height multiplied by this value.
    , th_seed = 0.45 
    # Pixel is added to a region if its height is greater than the current 
      # mean height of the region multiplied by this value.
    , th_cr = 0.55
    # Maximum value of the crown diameter of a detected tree (in pixels)
    , max_cr = 10
    # If treetops contains an attribute with the ID for each tree, the name of this attribute
    , ID = "treeID"
  )
  crowns_st <- algo()
# quick plot
  # plot(crowns_st, col = lidR::pastel.colors(200), main = "Individual Tree Crowns")

# transform crowns stars object to vector data
  crowns_sf <- crowns_st %>% 
    # convert to vector data and merge polygons with identical pixel values
    sf::st_as_sf(as_points = FALSE, merge = TRUE) %>% 
    # transform to same crs as rest of data # transformed las data above instead
    # sf::st_transform(crs = st_crs(bhef_boundary)) %>% 
    dplyr::mutate(
      tree_id = values
      , crown_area = sf::st_area(.)
    ) %>% 
    dplyr::relocate(tree_id, crown_area) %>% 
    dplyr::select(tree_id, crown_area) %>% 
    sf::st_set_precision(1e7) %>% 
    sf::st_make_valid(.) %>% 
    dplyr::filter(sf::st_is_valid(.))
  
# combine crown groups
  crowns_group <- sf::st_cast(
      sf::st_union(crowns_sf)
    , "POLYGON")
  # quick plot
    # plot(crowns_group, col = lidR::pastel.colors(200), main = "Tree Crown Groups")
  
  #create id column
    crowns_group <- crowns_group %>% 
      merge(., data.frame(geo_type = sf::st_geometry_type(crowns_group)), by.x=0, by.y=0, all.x=TRUE) %>% 
      dplyr::mutate(crown_group_id = as.numeric(as.factor(Row.names)))  %>% 
      dplyr::select(-c(geo_type, Row.names)) %>% 
      dplyr::relocate(crown_group_id) %>% 
      sf::st_as_sf(., sf_column_name = "geometry", crs = sf::st_crs(bhef_boundary))

# join back to individual tree crowns and summarize
  crowns_group_sum <- sf::st_intersection(tree_tops, crowns_group) %>% 
    # if need to keep group at tree level... break here
    sf::st_set_geometry(NULL) %>%
    dplyr::group_by(crown_group_id) %>%
    dplyr::summarise(
      count_trees = dplyr::n_distinct(treeID)
      , min_hgt_m = min(Z, na.rm = TRUE) 
      , max_hgt_m = max(Z, na.rm = TRUE) 
      , mean_hgt_m = mean(Z, na.rm = TRUE) 
      , median_hgt_m = median(Z, na.rm = TRUE) 
      , median_hgt_m = median(Z, na.rm = TRUE)
      , quant10_hgt_m = as.numeric( quantile(Z, probs = .10, na.rm = TRUE) )
      , quant25_hgt_m = as.numeric( quantile(Z, probs = .25, na.rm = TRUE) )
      , quant50_hgt_m = as.numeric( quantile(Z, probs = .50, na.rm = TRUE) )
      , quant75_hgt_m = as.numeric( quantile(Z, probs = .75, na.rm = TRUE) )
      , quant90_hgt_m = as.numeric( quantile(Z, probs = .90, na.rm = TRUE) )
      , count_trees_canopy = sum(ifelse(tree_class == 3, 1, 0), na.rm = TRUE)
      , count_trees_subcanopy = sum(ifelse(tree_class == 2, 1, 0), na.rm = TRUE)
      , count_trees_understory = sum(ifelse(tree_class == 1, 1, 0), na.rm = TRUE)
      , count_trees_ground = sum(ifelse(tree_class == 0, 1, 0), na.rm = TRUE)
    ) %>% 
    dplyr::ungroup() %>% 
    dplyr::arrange(crown_group_id) %>%
    dplyr::mutate(
      crown_group_class = dplyr::case_when(
        count_trees == 1 ~ "Individual Tree"
        , count_trees <= 10 
          & count_trees_canopy/count_trees >= .75 ~  "Small Group - Canopy"
        , count_trees <= 10 
          & count_trees_subcanopy/count_trees >= .75 ~  "Small Group - Subcanopy"
        , count_trees <= 10 ~  "Small Group - Mixed"
        , count_trees <= 40 
          & count_trees_canopy/count_trees >= .75 ~  "Medium Group - Canopy"
        , count_trees <= 40 
          & count_trees_subcanopy/count_trees >= .75 ~  "Medium Group - Subcanopy"
        , count_trees <= 40 ~  "Medium Group - Mixed"
        , count_trees_canopy/count_trees >= .75 ~ "Continuous - Canopy"
        , count_trees_subcanopy/count_trees >= .75 ~ "Continuous - Subcanopy"
        , TRUE ~ "Continuous - Mixed"
      )
    )
#attach summary statistics to spatial crown groups
  crowns_group <- crowns_group %>% 
    dplyr::left_join(crowns_group_sum, by = c("crown_group_id" = "crown_group_id")) %>% 
    dplyr::mutate(
      crown_group_area_ha = as.numeric(sf::st_area(.)) / 10000
      , trees_per_ha = count_trees / crown_group_area_ha
    )
}
```

```{r, warning=F, message=F, echo=FALSE, include=FALSE}
remove(list = c("kernel", "algo", "lazs", "ws_fn"))
gc()
```

## Lidar-Derived Crown Groups Summary

Tree classes are based on [Steel et al. 2021](https://besjournals.onlinelibrary.wiley.com/doi/pdf/10.1111/1365-2745.13764?casa_token=ob4t10qIRrsAAAAA:qYNA0_uawnsPC4EJ6O5Jz2GCeaA2BXNOUUJBIVFiS2ic-Pm9L5FafLhVtIWg4flYGsEsJgWgMNuPx0w). Height thresholds were used to define canopy (>8 m), subcanopy (28 m) and understory (12 m). Crown groups are defined by the number of trees in a crown group and the composition of canopy and subcanopy trees in the group:

  * **Individual Tree** : single tree (canopy or subcanopy) without interlocking crown
  
  * **Small Group - Canopy** : 2-10 trees with interlocking crowns where 75% or more of the trees are canopy (>8 m)
  
  * **Small Group - Subcanopy** : 2-10 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m)
  
  * **Small Group - Mixed** : 2-10 trees with interlocking crowns with neither canopy nor subcanopy comprising >75% of trees
  
  * **Medium Group - Canopy** : 11-40 trees with interlocking crowns where 75% or more of the trees are canopy (>8 m)
  
  * **Medium Group - Subcanopy** : 11-40 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m)
  
  * **Medium Group - Mixed** : 11-40 trees with interlocking crowns with neither canopy nor subcanopy comprising >75% of trees
  
  * **Continuous - Canopy** : >40 trees with interlocking crowns where 75% or more of the trees are canopy (>8 m)
  
  * **Continuous - Subcanopy** : >40 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m)
  
  * **Continuous - Mixed** : >40 trees with interlocking crowns with neither canopy nor subcanopy comprising >75% of trees
  

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# plot
  ggplot() +
    geom_sf(data = sf::st_intersection(crowns_group, rx_fire %>% dplyr::slice_head(n = 1))
      , aes(fill = crown_group_class)
      , lwd = 0
    ) +
    geom_sf(data = rx_fire %>% dplyr::slice_head(n = 1), alpha = 0, lwd = 1, color = "orangered") +
    scale_fill_viridis_d(option = "turbo", alpha = 0.9) + 
    labs(
      title = "BHEF Crown Groups Classes"
      , subtitle = paste0("sample Rx fire unit (", sf::st_crs(crowns_group)$input, ")")
    ) +
    xlab("") +
    ylab("") +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    theme_bw() +
    theme(
      legend.position = "bottom"
      , legend.title = element_blank()
      , axis.text = element_text(size = 8)
      # , panel.grid = element_blank()
      , panel.border = element_blank()
    )
  
```

### Crown Group Summary Statistics {#cg_sum}

```{r, warning=F, message=F, fig.width = 12, fig.height = 6}
# table
kable(crowns_group %>% sf::st_set_geometry(NULL) %>% 
        dplyr::group_by(
          crown_group_class
        ) %>% 
        dplyr::summarise(
          # plots = dplyr::n_distinct(plot)
          crown_groups = dplyr::n()
          , mean_m2 = mean(crown_group_area_ha, na.rm = TRUE) * 10000
          , trees_per_ha = mean(trees_per_ha, na.rm = TRUE)
          , mean_count_trees = mean(count_trees, na.rm = TRUE)
          , mean_count_trees_canopy = mean(count_trees_canopy, na.rm = TRUE)
          , mean_count_trees_subcanopy = mean(count_trees_subcanopy, na.rm = TRUE)
          , mean_hgt_m = mean(mean_hgt_m, na.rm = TRUE)
          # , min_hgt_m = min(min_hgt_m, na.rm = TRUE)
          # , max_hgt_m = max(max_hgt_m, na.rm = TRUE)
        ) %>% 
    dplyr::arrange(desc(mean_count_trees))
  , format = "html" 
  , caption = "Tree Crown Groups Summary Statistics"
  , digits = 1
  , col.names = c(
    "Classification"
    , "# crown groups"
    , "area (m2)"
    , "TPH"
    , "# trees"
    , "# canopy trees"
    , "# subcanopy trees"
    , "height (m)"
    # , "min hgt (m)"
    # , "max hgt (m)"
  )
  , align=rep('c', 5)
) %>% 
add_header_above(c(" " = 2, "Mean" = 6)) %>%
kable_styling(font_size = 9) %>% 
column_spec(1, bold = TRUE, width = "5em")


```

## Map Crowns and Rx Fire Area

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# make map
# different background map types: https://leaflet-extras.github.io/leaflet-providers/preview/
# names(leaflet.providers::providers_loaded()$providers)
mapviewOptions(homebutton = FALSE, basemaps = c("Esri.WorldImagery"))
# crop data
bhef_crowns_group <- sf::st_intersection(
  crowns_group 
    # dplyr::filter(crown_group_area_ha <= 2)
  , rx_fire %>% dplyr::select(unit) %>% dplyr::slice_sample(prop = .5)
) %>% 
sf::st_intersection(., bhef_boundary %>% dplyr::select(name))
# bhef_crowns_group <- sf::st_intersection(
#   crowns_group 
#     # dplyr::filter(crown_group_area_ha <= 2)
#   , sf::st_buffer(bhef_boundary %>% dplyr::select(name), dist = -500)
# )
# map
mapview(bhef_boundary
        , color = "black"
        , lwd = 3
        , alpha.regions = 0
        , label = FALSE
        , legend = FALSE
        , popup = FALSE
) +
mapview(rx_fire
        , color = "orangered"
        , lwd = 2
        , alpha.regions = 0
        , label = FALSE
        , legend = FALSE
        , popup = FALSE
) +
mapview(bhef_crowns_group
        , zcol = "crown_group_class"
        , col.regions = viridis::turbo(n=length(unique(bhef_crowns_group$crown_group_class)))
        , lwd = 0
        , alpha.regions = 0.8
        , label = c("crown_group_class")
        , legend = FALSE
          , popup = popupTable(
              bhef_crowns_group
              , zcol = c(
                "crown_group_class"
                , "count_trees"
                , "min_hgt_m"
                , "max_hgt_m"
                , "mean_hgt_m"
                , "count_trees_canopy"
                , "count_trees_subcanopy"
              )
              , row.numbers = FALSE
              , feature.id = FALSE
            )
) 
```

*Note: crown groups shown for only 50% of Rx Fire units (to enhance rendering performance). Crown group data for entire BHEF is still available.*

## Write Out Data

```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6, results='hide'}
if(overwrite_it == FALSE){
  print("Proceeding to next section without processing or overwriting data...")
}else{
# save cleaned data for reading to R later
sf::st_write(crowns_group, "../data/crowns_group.gpkg", append = FALSE)
sf::st_write(tree_tops, "../data/tree_tops.gpkg", append = FALSE)
stars::write_stars(chm, "../data/chm.tif", append = FALSE)
stars::write_stars(crowns_st, "../data/crowns_st.tif", append = FALSE)
}
```




```{r, warning=FALSE, message=FALSE, eval=FALSE, echo=FALSE, include=FALSE}
xxx <- chm_smooth %>%
  # create classes based on Steel et al. 2021
  dplyr::mutate(
    veg_class = dplyr::case_when(
      values > 8 ~ 3 # canopy
      , values >= 2 ~ 2 # subcanopy
      , values >= 1 ~ 1 # understory
      , TRUE ~ 0 # ground
    )
  ) %>%
  merge() %>%
  setNames("z") %>%
  st_set_dimensions(names = c("x", "y", "band")) %>%
  # select only the class band
  dplyr::slice(band, 2) %>%
  # convert to vector data and merge polygons with identical values
  sf::st_as_sf(as_points = FALSE, merge = TRUE) %>%
  # transform to same crs as rest of data
  sf::st_transform(crs = sf::st_crs(bhef_boundary))

names(xxx)[1] = "veg_class"

ggplot() +
  geom_sf(data = xxx, aes(fill = as.factor(veg_class)), lwd = 0 ) +
  scale_fill_viridis_d() +
  theme_bw()


```


```{r, warning=F, message=FALSE, eval=FALSE, include=FALSE, echo=FALSE, results='hide'}
## Load NAIP Imagery
# tif = system.file("tif/L7_ETMs.tif", package = "stars")
# x = read_stars(tif)
# x[,,,c(6,5,4,3)]
# r = st_rgb(x[,,,c(6,5,4,3)], 3, use_alpha=TRUE) # now R=6,G=5,B=4,alpha=3
# if (require(ggplot2)) {
#  ggplot() + geom_stars(data = r) + scale_fill_identity()
# }



# load with stars
tifs <- list.files("../data/naip/", pattern = "\\.tif$", full.names = TRUE)

# x <- stars::read_stars(imgs[1])
naip_st <- stars::read_stars(tifs[1])
plot(naip_st %>% dplyr::slice(band, 1:3), axes = TRUE)



naip_rgb <- stars::st_rgb(
  naip_st[,,,c(1, 2, 3)]
  , dimension = 3
  , use_alpha = FALSE
  , maxColorValue = 255L
)
 
# ggplot() +
#   stars::geom_stars(data = naip_rgb) +
#   scale_fill_identity()

```



```{r, warning=F, message=FALSE, eval=FALSE, include=FALSE, echo=FALSE, results='hide'}
# apply itd to smoothed kernel chm?
  methods(class = "stars")


# polygon_list = list(rbind(c(-1, 1), c(-1, -1), c(1, -1), c(1, 1), c(-1, 1)))
  polygon_list = list(rbind(
    # c(x, y, z)
    c(sf::st_bbox(bhef_boundary)[1], sf::st_bbox(bhef_boundary)[4]) # upper left
    , c(sf::st_bbox(bhef_boundary)[1], sf::st_bbox(bhef_boundary)[2]) # lower left
    , c(sf::st_bbox(bhef_boundary)[3], sf::st_bbox(bhef_boundary)[2]) # lower right
    , c(sf::st_bbox(bhef_boundary)[3], sf::st_bbox(bhef_boundary)[4]) # upper right
    , c(sf::st_bbox(bhef_boundary)[1], sf::st_bbox(bhef_boundary)[4]) # upper left
    )
  )
  hey_box <- sf::st_polygon(polygon_list) %>% sf::st_sfc(crs = sf::st_crs(bhef_boundary))
  
  ggplot() + 
    geom_sf(data = hey_box, fill = "transparent", lwd = 2, color = "red") + 
    stars::geom_stars(data = bhef_elev[bhef_boundary]) +
    scale_fill_viridis_c(option = "cividis", alpha = 0.9, na.value = "transparent") +
    theme_bw()
  
  
```

<!--chapter:end:02_analysis_lidar.Rmd-->

# Forest Cover Analysis {#cover_analysis}

```{r, include=FALSE, warning=F, message=F}
# data mgmt
library(tidyverse)
library(lubridate)
# visualization
library(RColorBrewer)
library(scales)
library(ggrepel)
library(viridis)
library(kableExtra)
# plotting
library(ggpubr)
library(pdftools)
library(qpdf)
library(gridExtra)
library(grid)
# spatial
library(sf)
library(stars)

```

```{r, warning=F, message=F, results='hide'}
# turn off the s2 processing 
## https://stackoverflow.com/questions/68478179/how-to-resolve-spherical-geometry-failures-when-joining-spatial-data
sf::sf_use_s2(FALSE)
```

## Set Contour Line Interval

```{r, warning=F, message=F, results='hide', fig.width = 10, fig.height = 6}
#######################################################
#######################################################
# Set Contour Line Interval
#######################################################
#######################################################
contour_int_m <- 5
```



## Read Data

[Vector data](#vector_data) and [forest cover data](#lidar_data) created in prior chapters.

```{r, warning=F, message=F, fig.width = 10, fig.height = 6, results='hide'}
# read
forests_bhnf <- sf::st_read("../data/forests_bhnf.gpkg")
bhef_boundary <- sf::st_read("../data/bhef_boundary.gpkg")
bhef_harvests <- sf::st_read("../data/bhef_harvests.gpkg")
research_plots <- sf::st_read("../data/research_plots.gpkg")
stem_map <- sf::st_read("../data/stem_map.gpkg")
rx_fire <- sf::st_read("../data/rx_fire.gpkg")
# # forest cov
crowns_group <- sf::st_read("../data/crowns_group.gpkg")
# tree_tops <- sf::st_read("../data/tree_tops.gpkg")
# chm <- stars::read_stars("../data/chm.tif")
# elevation
bhef_elev <- stars::read_stars("../data/bhef_elev.tif")
```

### Data Preparation

```{r, warning=F, message=F, fig.width = 10, fig.height = 6, results='hide'}
# create dir for pdf plots
  hey_dir <- "../data/pdf"
  if(dir.exists(hey_dir)==FALSE){
    dir.create(hey_dir)
  }else{ # delete all files if folder exists
    file.remove(list.files(hey_dir, full.names = TRUE))
  }

################################################
################################################
# add colors to the crowns group
################################################
################################################
  all_classes <- c(sort(unique(crowns_group$crown_group_class)), "Non-Tree Cover", "Post-Lidar Harvest")
  col_data <- data.frame(
    crown_group_class = all_classes
    , crown_group_class_color = c(
        viridis::turbo(n = length(unique(crowns_group$crown_group_class)), alpha = 0.5)
        , "#48526B80"
        , "#9E967780"
    )
  ) %>% 
  dplyr::mutate(row_n = dplyr::row_number())
  # set up for plotting
  col_data$crown_group_class <- factor(col_data$crown_group_class, levels=unique(col_data$crown_group_class))
  scale_fill_manual_values_fill <- col_data$crown_group_class_color
  names(scale_fill_manual_values_fill) <- paste(col_data$crown_group_class)

  # attach 
  crowns_group <- crowns_group %>% 
    # dplyr::select(-crown_group_class_color) %>% 
    dplyr::left_join(col_data, by = c("crown_group_class"="crown_group_class"))

################################################
################################################
# create contour data
################################################
################################################
# sequence by 5's to get 5m breaks list for contour
seq_brk <- seq(0, 40000, contour_int_m)
# create contour data
bhef_contour <- bhef_elev %>% 
  stars::st_contour(
    na.rm = TRUE
    , contour_lines = FALSE
    , breaks = # classInt::classIntervals(na.omit(as.vector(x[[1]])))$brks
        seq_brk[
          seq_brk > min(na.omit(as.vector(bhef_elev[[1]]))) - contour_int_m 
          & seq_brk < max(na.omit(as.vector(bhef_elev[[1]]))) + contour_int_m
        ]
  )

```

### Read NAIP Data

[National Agriculture Imagery Program (NAIP)](https://naip-usdaonline.hub.arcgis.com/) imagery for the BHEF was *manually* ;/ downloaded from the [USGS Science Data Explorer](https://ers.cr.usgs.gov/). 

```{r, warning=F, message=F, fig.width = 10, fig.height = 6, results='hide'}
################################################
################################################
# load naip tif with stars
################################################
################################################
naip_st <- stars::read_stars("../data/naip/bhef_naip_20200809_1m.tif") 

# crop
naip_st <- naip_st %>% 
  sf::st_crop(., sf::st_buffer(sf::st_transform(bhef_boundary, crs = sf::st_crs(naip_st)), dist = 500)) %>% 
  setNames("value") %>% 
  dplyr::mutate(value = ifelse(is.na(value), 0, value)) # black out missing band values

# plot(naip_st %>% dplyr::slice(band, 1:3), axes = TRUE)
# plot(naip_st[,,,3:1], axes = TRUE)

# set rgb image
# band 3 = red, band 2 = green, band 1 = blue
naip_rgb <- stars::st_rgb(
  naip_st[,,,3:1]
  , dimension = 3
  , use_alpha = FALSE
  # , stretch = "histogram"
  , probs = c(0.005, 0.995)
  , stretch = "percent"
)
```

## Post-Lidar Acquisition Timber Harvests

Lidar data was collected in 2017. Spatially identify areas within BHEF where timber harvest (not including TSI) treatments occurred in 2017 or later. 

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# find harvests after lidar collection
harvests_post_lidar <- bhef_harvests %>% 
  dplyr::filter(year_id >= 2017) %>% 
  sf::st_intersection(bhef_boundary)
# write data
sf::st_write(harvests_post_lidar, "../data/harvests_post_lidar.gpkg", append = FALSE)

# plot
ggplot() +
  geom_sf(data = harvests_post_lidar
      , aes(fill = treatment_type_grp)
      , lwd = 0
    ) +
  geom_sf(data = bhef_boundary, alpha = 0, lwd = 1, color = "black", linetype = "dashed") +
  geom_sf(data = rx_fire, alpha = 0, lwd = 1, color = "orangered") +
  geom_sf_label(data = rx_fire, aes(label = unit)
    , label.size = NA
    , alpha = 0
    , size = 3
  ) +
  geom_sf_label(data = harvests_post_lidar, aes(label = year_id)
    , label.size = NA
    , alpha = 0
    , size = 2.5
  ) +
  scale_fill_viridis_d(option = "viridis", alpha = 0.8) + 
  labs(
    title = "BHEF Post-Lidar Acquisition Timber Harvests"
    , subtitle = paste0("Rx fire units")
    , caption = paste0(
      "*Percent of BHEF Area Harvested Post-Lidar: "
      , scales::percent(
        as.numeric(sum(sf::st_area(harvests_post_lidar))) / as.numeric(sum(sf::st_area(bhef_boundary)))
        , accuracy = 0.1
      )
    )
  ) +
  xlab("") +
  ylab("") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_bw() +
  theme(
    legend.position = "bottom"
    , legend.title = element_blank()
    , axis.text = element_text(size = 8)
    , panel.border = element_blank()
    , plot.title = element_text(size = 12, face = "bold", margin = margin(0,0,2,0))
    , plot.subtitle = element_text(size=8, face="italic", color="orangered", margin = margin(0,0,0,0))
    , plot.caption = element_text(size=10, face="bold.italic")
  )
# save plot
ggplot2::ggsave(
    filename = paste0("../data/pdf/post_lidar_bhef_tmbrhrvst.pdf")
    , plot = ggplot2::last_plot()
    , width = 8.5
    , height = 11
    , units = "in"
    , dpi = "print"
  )
qpdf::pdf_rotate_pages("../data/pdf/post_lidar_bhef_tmbrhrvst.pdf", angle = 270, output = "../data/pdf/00post_lidar_bhef_tmbrhrvst.pdf")
file.remove("../data/pdf/post_lidar_bhef_tmbrhrvst.pdf")
```


There have been **`r scales::comma(as.numeric(sum(sf::st_area(harvests_post_lidar)))/10000, accuracy = 1)` hectares** in BHEF with timber harvest treatments completed after the lidar acquisition in 2017. This represents **`r scales::percent(as.numeric(sum(sf::st_area(harvests_post_lidar))) / as.numeric(sum(sf::st_area(bhef_boundary))), accuracy = 0.1)`** of the total BHEF area (**`r scales::comma( as.numeric(sf::st_area(bhef_boundary))/10000, accuracy = 1)` hectares**).
      

### Join Harvests to Rx Fire Units

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
rx_fire <- rx_fire %>% 
  dplyr::left_join(
    rx_fire %>% 
      dplyr::select(unit) %>% 
      sf::st_intersection(
        sf::st_union(harvests_post_lidar %>% dplyr::select(nffid))
      ) %>% 
      dplyr::mutate(postlidar_harvest_area_m2 = as.numeric(sf::st_area(.))) %>% 
      sf::st_set_geometry(NULL) %>% 
      dplyr::group_by(unit) %>% 
      dplyr::summarise(postlidar_harvest_area_m2 = sum(postlidar_harvest_area_m2)) %>% 
      dplyr::ungroup() %>% 
      dplyr::select(unit, postlidar_harvest_area_m2)
    , by = c("unit" = "unit")
  ) %>% 
  dplyr::mutate(
    has_postlidar_harvest = ifelse(!is.na(postlidar_harvest_area_m2), 1, 0)
    , postlidar_harvest_area_m2 = ifelse(!is.na(postlidar_harvest_area_m2), postlidar_harvest_area_m2, 0)
    , postlidar_harvest_area_ha = ifelse(!is.na(postlidar_harvest_area_m2), postlidar_harvest_area_m2/10000, 0)
    , area_m2 = as.numeric(sf::st_area(.))
    , area_ha = as.numeric(sf::st_area(.)) / 10000
    , pct_postlidar_harvest_area = postlidar_harvest_area_m2 / area_m2
  )


# plot
ggplot(data = rx_fire) + 
  geom_col(aes(y = reorder(unit, pct_postlidar_harvest_area), x = area_ha)
           , width = 0.7, fill = "navy", alpha = 0.5
  ) +
  geom_col(aes(y = reorder(unit, pct_postlidar_harvest_area), x = postlidar_harvest_area_ha)
           , width = 0.7, fill = "navy", alpha = 0.9
  ) +
  geom_text(
    aes(y = reorder(unit, pct_postlidar_harvest_area)
        , x = 0
        , label = scales::percent(pct_postlidar_harvest_area, accuracy = 1)
      )
    , color = "white"
    , size = 3
    , fontface = "bold"
    , hjust = -0.1
    , vjust = 0.1
  ) +
  labs(
      title = "Percent of Rx Fire Unit Area with Timber Harvest Post-Lidar Acquisition"
      # , subtitle = "within BHEF boundary and bounding box of research plot area"
    ) +
  xlab("Area (ha)") +
  ylab("Rx Fire Unit") +
  scale_x_continuous(labels = scales::comma) +
  theme_bw() +
  theme(
    legend.position = "none"
    , plot.title = element_text(size = 12, face = "bold", margin = margin(0,0,2,0))
    , axis.text.y = element_text(size = 10, face = "bold")
  )
```


## Forest Cover Summary

In [prior chapter](#lidar_data), interlocking tree crowns were grouped together to form distinct tree crown classes. Experimental Forest-wide summary statistics were shown [here](#cg_sum). Explore the canopy cover distributions further.

For reference, tree classes are based on [Steel et al. 2021](https://besjournals.onlinelibrary.wiley.com/doi/pdf/10.1111/1365-2745.13764?casa_token=ob4t10qIRrsAAAAA:qYNA0_uawnsPC4EJ6O5Jz2GCeaA2BXNOUUJBIVFiS2ic-Pm9L5FafLhVtIWg4flYGsEsJgWgMNuPx0w). Height thresholds were used to define canopy (>8 m), subcanopy (28 m) and understory (12 m). Crown groups are defined by the number of trees in a crown group and the composition of canopy and subcanopy trees in the group:

  * **Individual Tree** : single tree (canopy or subcanopy) without interlocking crown
  
  * **Small Group - Canopy** : 2-10 trees with interlocking crowns where 75% or more of the trees are canopy (>8 m)
  
  * **Small Group - Subcanopy** : 2-10 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m)
  
  * **Small Group - Mixed** : 2-10 trees with interlocking crowns with neither canopy nor subcanopy comprising >75% of trees
  
  * **Medium Group - Canopy** : 11-40 trees with interlocking crowns where 75% or more of the trees are canopy (>8 m)
  
  * **Medium Group - Subcanopy** : 11-40 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m)
  
  * **Medium Group - Mixed** : 11-40 trees with interlocking crowns with neither canopy nor subcanopy comprising >75% of trees
  
  * **Continuous - Canopy** : >40 trees with interlocking crowns where 75% or more of the trees are canopy (>8 m)
  
  * **Continuous - Subcanopy** : >40 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m)
  
  * **Continuous - Mixed** : >40 trees with interlocking crowns with neither canopy nor subcanopy comprising >75% of trees

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# create data for defining crown class
crown_group_class <- c(
  "Individual Tree"
  , "Small Group - Canopy"
  , "Small Group - Subcanopy"
  , "Small Group - Mixed"
  , "Medium Group - Canopy"
  , "Medium Group - Subcanopy"
  , "Medium Group - Mixed"
  , "Continuous - Canopy"
  , "Continuous - Subcanopy"
  , "Continuous - Mixed"
  , "Non-Tree Cover"
  , "Post-Lidar Harvest"
)
description <- c(
  "single tree (canopy or subcanopy) without interlocking crown"
  , "2-10 trees with interlocking crowns where 75% or more of the trees are canopy (>8 m)"
  , "2-10 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m)"
  , "2-10 trees with interlocking crowns with neither canopy nor subcanopy comprising >75% of trees"
  , "11-40 trees with interlocking crowns where 75% or more of the trees are canopy (>8 m)"
  , "11-40 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m)"
  , "11-40 trees with interlocking crowns with neither canopy nor subcanopy comprising >75% of trees"
  , ">40 trees with interlocking crowns where 75% or more of the trees are canopy (>8 m)"
  , ">40 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m)"
  , ">40 trees with interlocking crowns with neither canopy nor subcanopy comprising >75% of trees"
  , "Any ground cover (vegetation or non-vegetation) less than 2 m in height in 2017"
  , "Timber harvest occured after the BHEF Lidar data acquisition in 2017 (based on FACTS)"
)
temp_dta <- data.frame(
  Classification = crown_group_class
  , Description = description
)
# Export PDF
pdf("../data/pdf/01crown_class_desc.pdf", paper = "USr", height = 8.5, width = 11)
grid::grid.draw(gridExtra::tableGrob(
    temp_dta
    , theme = ttheme_default(base_size = 11, padding = unit(c(8, 8), "mm"))
))
dev.off()  


# table
kable(temp_dta
  , format = "html" 
  , caption = "Crown Class Description"
  , col.names = c(
    "Classification"
    , "Description"
  )
) %>% 
kable_styling(font_size = 11) %>% 
column_spec(1, bold = TRUE, width = "5em") %>% 
column_spec(2, width = "40em")
```

```{r, warning=F, message=F, echo=FALSE, include=FALSE}
remove(crown_group_class, description, temp_dta)
gc()
```


## Total Area by Crown Group Class

The total area of the BHEF is approximately **`r scales::comma( as.numeric(sf::st_area(bhef_boundary))/10000, accuracy = 1)` hectares (`r scales::comma( as.numeric(sf::st_area(bhef_boundary))/4047, accuracy = 1)` acres)**. 

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# set up data
bhef_area_ha <- sum(as.numeric(sf::st_area(bhef_boundary))/10000)
forestcov_area_ha <- sum(as.numeric(sf::st_area(sf::st_intersection(crowns_group, bhef_boundary)))/10000, na.rm = TRUE)
non_forestcov_area_ha <- bhef_area_ha - forestcov_area_ha
temp_dta <- data.frame(
  crown_group_class = "Non-Tree Cover"
  , area_ha = non_forestcov_area_ha
)
crowns_group_area_sum <- crowns_group %>% 
  sf::st_intersection(bhef_boundary) %>% 
  dplyr::mutate(crown_group_area_ha = as.numeric(sf::st_area(.))/10000) %>% 
  sf::st_set_geometry(NULL) %>% 
  dplyr::group_by(crown_group_class) %>%
  dplyr::summarise(area_ha = sum(crown_group_area_ha, na.rm = TRUE)) %>% 
  dplyr::ungroup() %>% 
  dplyr::bind_rows(temp_dta) %>% 
  dplyr::mutate(
    pct_area = area_ha / bhef_area_ha
  ) %>% 
  dplyr::arrange(desc(area_ha))
# plot
ggplot(data = crowns_group_area_sum) + 
  geom_col(aes(y = reorder(crown_group_class, area_ha), x = area_ha, fill = area_ha), width = 0.7) +
  geom_text(
    aes(y = reorder(crown_group_class, area_ha), x = area_ha + 2, label = scales::comma(area_ha, accuracy = 1))
    , color = "black"
    , size = 4
    , fontface = "bold"
    # , position = position_dodge(0.9)
    , hjust = -0.1
    , vjust = -0.5
  ) +
  geom_text(
    aes(y = reorder(crown_group_class, area_ha), x = area_ha + 2, label = scales::percent(pct_area, accuracy = 1))
    , color = "black"
    , size = 3
    # , position = position_dodge(0.9)
    , hjust = -0.1
    , vjust = 0.5
  ) +
  labs(
      title = "BHEF Area (ha) by Crown Group Class"
      , subtitle = "*Note: a tree is classified as cover >= 2m tall in 2017 based on lidar acquisition"
    ) +
  xlab("Area (ha)") +
  ylab("") +
  scale_x_continuous(labels = scales::comma) +
  scale_fill_viridis_c(alpha = 0.7, option = "cividis", direction = -1) +
  theme_bw() +
  theme(
    legend.position = "none"
    , plot.title = element_text(size = 12, face = "bold", margin = margin(0,0,2,0))
    , plot.subtitle = element_text(size=8, face="italic", color="gray20", margin = margin(0,0,0,0))
    , axis.text.y = element_text(size = 10, face = "bold")
  )
# save plot
ggplot2::ggsave(
    filename = paste0("../data/pdf/02cover_class_bhef_2017.pdf")
    , plot = ggplot2::last_plot()
    , width = 11
    , height = 8.5
    , units = "in"
    , dpi = "print"
  )


```

```{r, warning=F, message=F, echo=FALSE, include=FALSE}
remove(bhef_area_ha, forestcov_area_ha, non_forestcov_area_ha, temp_dta)
gc()
```

## No Harvest Post-Lidar Area by Crown Group Class

The total area of the BHEF which has *not* been harvested after the 2017 lidar acquisition is approximately **`r scales::comma(as.numeric(sum(sf::st_area(sf::st_difference(bhef_boundary, sf::st_union(harvests_post_lidar)))))/10000, accuracy = 1)` hectares (`r scales::comma( as.numeric(sum(sf::st_area(sf::st_difference(bhef_boundary, sf::st_union(harvests_post_lidar)))))/4047, accuracy = 1)` acres)**. 

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# set up data
bhef_area_ha <- sum(as.numeric(sf::st_area(sf::st_difference(bhef_boundary, sf::st_union(harvests_post_lidar))))/10000)
forestcov_area_ha <- sum(as.numeric(sf::st_area(sf::st_intersection(crowns_group, sf::st_difference(bhef_boundary, sf::st_union(harvests_post_lidar)))))/10000, na.rm = TRUE)
non_forestcov_area_ha <- bhef_area_ha - forestcov_area_ha
temp_dta <- data.frame(
  crown_group_class = "Non-Tree Cover"
  , area_ha = non_forestcov_area_ha
)
crowns_group_area_sum_woharv <- crowns_group %>% 
  sf::st_intersection(sf::st_difference(bhef_boundary, sf::st_union(harvests_post_lidar))) %>% 
  dplyr::mutate(crown_group_area_ha = as.numeric(sf::st_area(.))/10000) %>% 
  sf::st_set_geometry(NULL) %>% 
  dplyr::group_by(crown_group_class) %>%
  dplyr::summarise(area_ha = sum(crown_group_area_ha, na.rm = TRUE)) %>% 
  dplyr::ungroup() %>% 
  dplyr::bind_rows(temp_dta) %>% 
  dplyr::mutate(
    pct_area = area_ha / bhef_area_ha
  ) %>% 
  dplyr::arrange(desc(area_ha))
# plot
ggplot(data = crowns_group_area_sum_woharv) + 
  geom_col(aes(y = reorder(crown_group_class, area_ha), x = area_ha, fill = area_ha), width = 0.7) +
  geom_text(
    aes(y = reorder(crown_group_class, area_ha), x = area_ha + 2, label = scales::comma(area_ha, accuracy = 1))
    , color = "black"
    , size = 4
    , fontface = "bold"
    # , position = position_dodge(0.9)
    , hjust = -0.1
    , vjust = -0.5
  ) +
  geom_text(
    aes(y = reorder(crown_group_class, area_ha), x = area_ha + 2, label = scales::percent(pct_area, accuracy = 1))
    , color = "black"
    , size = 3
    # , position = position_dodge(0.9)
    , hjust = -0.1
    , vjust = 0.5
  ) +
  labs(
      title = "No Harvest Post-Lidar BHEF Area (ha) by Crown Group Class"
      , subtitle = "*Note: a tree is classified as cover >= 2m tall in 2017 based on lidar acquisition"
    ) +
  xlab("Area (ha)") +
  ylab("") +
  scale_x_continuous(labels = scales::comma) +
  scale_fill_viridis_c(alpha = 0.7, option = "cividis", direction = -1) +
  theme_bw() +
  theme(
    legend.position = "none"
    , plot.title = element_text(size = 12, face = "bold", margin = margin(0,0,2,0))
    , plot.subtitle = element_text(size=8, face="italic", color="gray20", margin = margin(0,0,0,0))
    , axis.text.y = element_text(size = 10, face = "bold")
  )
# save plot
ggplot2::ggsave(
    filename = paste0("../data/pdf/03cover_class_bhef_noharv.pdf")
    , plot = ggplot2::last_plot()
    , width = 11
    , height = 8.5
    , units = "in"
    , dpi = "print"
  )

```

```{r, warning=F, message=F, echo=FALSE, include=FALSE}
remove(bhef_area_ha, forestcov_area_ha, non_forestcov_area_ha, temp_dta)
gc()
```

## Spatial Arrangement by Crown Group Class

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# function to map for each cover class
my_full_area_map <- function(my_data, my_class){
  #generate title
  my_title <- paste0(my_class)
  my_caption <- paste0(
    scales::percent(
      (crowns_group_area_sum %>% dplyr::filter(crown_group_class==my_class))$pct_area
      , accuracy = 1
    )
    , " of total BHEF Area"
  )
  #plot
  (
  ggplot() +
      geom_sf(data = bhef_boundary, alpha = 0, lwd = 1, color = "black", linetype = "dashed") +
      geom_sf(data = rx_fire, alpha = 0, lwd = 1, color = "orangered") +
      geom_sf(data = my_data %>% 
                dplyr::filter(crown_group_class==my_class)
          , fill = (col_data %>% dplyr::filter(crown_group_class==my_class))$crown_group_class_color
          , lwd = NA
      ) +
      geom_sf_label(data = rx_fire, aes(label = unit)
        , label.size = NA
        , alpha = 0
        , size = 2
      ) +
      labs(
        title = my_title
        , subtitle = "Spatial Arrangement on BHEF"
        , caption = my_caption
      ) +
      xlab("") +
      ylab("") +
      scale_x_continuous(expand = c(0, 0)) +
      scale_y_continuous(expand = c(0, 0)) +
      theme_bw() +
      theme(
        legend.position = "none"
        , legend.direction = "horizontal"
        , legend.title = element_blank()
        , axis.text = element_text(size = 8)
        , panel.border = element_blank()
        , plot.title = element_text(size = 12, face = "bold", margin = margin(0,0,2,0))
        , plot.subtitle = element_text(size=10, color="gray20", margin = margin(0,0,0,0))
        , plot.caption = element_text(size=10, face="bold.italic")
      )
    
  )
}

# plot with loop to create a plot for each class
my_classes <- sort(unique(crowns_group$crown_group_class))
for (i in 1:length(my_classes)) {
# for (i in 1:3) {
  print( 
    my_full_area_map(
      my_data = crowns_group %>% sf::st_intersection(bhef_boundary)
      , my_class = my_classes[i]
    ) 
  )
}
```

## Rx Fire Unit Summary

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# summarize area by coverage type
temp_rx_crown <- rx_fire %>% 
  dplyr::select(unit) %>% 
  sf::st_difference(
    sf::st_union(harvests_post_lidar %>% dplyr::select(nffid))
  ) %>%
  sf::st_intersection(
    crowns_group %>% dplyr::select(crown_group_class)
  ) %>% 
  dplyr::mutate(area_m2 = as.numeric(sf::st_area(.))) %>% 
  sf::st_set_geometry(NULL) %>% 
  dplyr::group_by(unit, crown_group_class) %>% 
  dplyr::summarise(area_m2 = sum(area_m2)) %>% 
  dplyr::ungroup() %>% 
  dplyr::select(unit, crown_group_class, area_m2)
# join to base rx fire data
rx_crown_sum <- rx_fire %>% 
  sf::st_set_geometry(NULL) %>% 
  dplyr::select(unit, postlidar_harvest_area_m2) %>% 
  dplyr::rename(area_m2 = postlidar_harvest_area_m2) %>% 
  dplyr::mutate(crown_group_class = "Post-Lidar Harvest") %>% 
  dplyr::relocate(names(temp_rx_crown)) %>% 
  dplyr::bind_rows(temp_rx_crown) %>% 
  dplyr::left_join(
    rx_fire %>% 
      sf::st_set_geometry(NULL) %>% 
      dplyr::select(unit, area_m2) %>% 
      dplyr::rename(total_area_m2 = area_m2)
    , by = c("unit" = "unit")
  )
# find non-tree cover
rx_crown_sum <- rx_crown_sum %>% 
  dplyr::bind_rows(
    # find left over area
    rx_crown_sum %>% 
      dplyr::group_by(unit) %>% 
      dplyr::summarise(cov_area_m2 = sum(area_m2), total_area_m2 = max(total_area_m2)) %>% 
      dplyr::ungroup() %>% 
      dplyr::mutate(
        area_m2 = total_area_m2 - cov_area_m2
        , crown_group_class = "Non-Tree Cover"
      ) %>% 
      dplyr::select(names(rx_crown_sum)) %>% 
      dplyr::relocate(names(rx_crown_sum))
  ) %>% 
  dplyr::mutate(
    pct_area = area_m2/total_area_m2
    , area_ha = area_m2/10000
  ) %>% 
  dplyr::arrange(unit, crown_group_class) %>% 
  dplyr::left_join(col_data, by = c("crown_group_class" = "crown_group_class"))

# summarize for plot
rx_crown_sum %>% 
  dplyr::mutate(
    cover = dplyr::case_when(
      crown_group_class %in% c("Non-Tree Cover", "Post-Lidar Harvest") ~ crown_group_class
      , startsWith(crown_group_class, "Continuous") ~ "Continuous Tree Cover"
      , TRUE ~ "Sm/Med Grp. & Indiv. Tree Cover"
    )
    , cover_num = dplyr::case_when(
      crown_group_class == "Non-Tree Cover" ~ 4
      , crown_group_class == "Post-Lidar Harvest" ~ 3
      , startsWith(crown_group_class, "Continuous") ~ 1
      , TRUE ~ 2
    )
  ) %>% 
  dplyr::group_by(unit, cover, cover_num) %>% 
  dplyr::summarise(
    pct_area = sum(pct_area)
    , area_m2 = sum(area_m2)
    , total_area_ha = max(total_area_m2)/10000
  ) %>% 
  dplyr::ungroup() %>% 
# plot
ggplot() + 
  geom_col(aes(
      y = reorder(unit, total_area_ha)
      , x = pct_area
      , fill = reorder(cover, -cover_num)
    )
    , width = 0.7
  ) +
  scale_fill_viridis_d(option = "cividis", alpha = 1, direction = -1) +
  geom_text(
    aes(
      y = reorder(unit, total_area_ha)
      , x = pct_area
      , label = scales::percent(
          ifelse(pct_area < 0.05, NA, pct_area)
        , accuracy = 1)
      , group = reorder(cover, -cover_num)
    )
    , position = position_stack(vjust = 0.5)
    , color = "white"
    , size = 3
    , fontface = "bold"
    # , hjust = -0.1
    # , vjust = 0.1
  ) +
  geom_text(
    aes(
      y = reorder(unit, total_area_ha)
      , x = 1.06
      , label = paste0(scales::comma(
            total_area_ha
          , accuracy = 1)
        , " ha"
      )
    )
    , color = "black"
    , size = 4
    , fontface = "bold"
  ) +
  labs(
      title = "Cover Classification of Rx Fire Unit Area"
      , subtitle = "*Note: a tree is classified as cover >= 2m tall in 2017 based on lidar acquisition"
    ) +
  xlab("% of Area") +
  ylab("Rx Fire Unit") +
  scale_x_continuous(labels = scales::percent) +
  theme_bw() +
  theme(
    plot.title = element_text(size = 12, face = "bold", margin = margin(0,0,2,0))
    , plot.subtitle = element_text(size=8, face="italic", color="gray20", margin = margin(0,0,0,0))
    , axis.text.y = element_text(size = 10, face = "bold")
    , legend.title = element_blank()
  )
# save plot
ggplot2::ggsave(
    filename = paste0("../data/pdf/04cover_class_by_unit.pdf")
    , plot = ggplot2::last_plot()
    , width = 11
    , height = 8.5
    , units = "in"
    , dpi = "print"
  )
```

```{r, warning=F, message=F, echo=FALSE, include=FALSE}
remove(temp_rx_crown)
gc()
```

### Rx Fire Unit Cover Class

Create a plot function for cover class by fire unit.

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
plot_cover_class_bars <- function(my_unit){
  (
    # plot
    ggplot(data = rx_crown_sum %>% dplyr::filter(unit == my_unit)) + 
      geom_col(
        aes(
          y = reorder(crown_group_class, desc(crown_group_class))
          , x = area_ha
          , fill = crown_group_class
        )
        , width = 0.7
      ) +
      scale_fill_manual(values = scale_fill_manual_values_fill) +
      geom_text(
        aes(
          y = reorder(crown_group_class, desc(crown_group_class))
          , x = area_ha + 0.5
          , label = scales::comma(area_ha, accuracy = 1)
        )
        , color = "black"
        , size = 3
        , fontface = "bold"
        # , position = position_dodge(0.9)
        , hjust = 0.6
        , vjust = -0.3
      ) +
      geom_text(
        aes(
          y = reorder(crown_group_class, desc(crown_group_class))
          , x = area_ha + 0.5
          , label = scales::percent(pct_area, accuracy = 1)
        )
        , color = "black"
        , size = 2.5
        # , position = position_dodge(0.9)
        , hjust = 0.4
        , vjust = 0.7
      ) +
      labs(
          # title = paste0("Rx Fire Unit: ", my_unit)
          subtitle = "Area (ha) by Crown Group Class"
        ) +
      xlab("Area (ha)") +
      ylab("") +
      scale_x_continuous(labels = scales::comma) +
      theme_bw() +
      theme(
        legend.position = "none"
        # , plot.title = element_text(size = 12, face = "bold", margin = margin(0,0,2,0))
        , plot.subtitle = element_text(size=8, color="gray20", margin = margin(0,0,0,0))
        , axis.text.y = element_text(size = 7, face = "bold")
        , axis.text.x = element_text(size = 7)
        , axis.title.x = element_text(size = 7)
      )
  )
}
# print(plot_cover_class_bars(my_unit = rx_fire$unit[11]))
```

### Rx Fire Unit Cover Map

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
plot_cover_class_map <- function(my_unit){
  (
    #########################################
    #########################################
    # map of unit w/ canopy
    #########################################
    #########################################
    ggplot() +
      stars::geom_stars(
        data = naip_rgb[
          rx_fire %>% dplyr::filter(unit == my_unit) %>% 
          sf::st_buffer(dist = 50) %>% 
          sf::st_transform(crs = sf::st_crs(naip_st)) %>% 
          sf::st_bbox()
        ] 
      ) +
      scale_fill_identity(na.value = "transparent") + # !!! don't take this out or RGB plot will kill your computer
      geom_sf(data = rx_fire %>%
              dplyr::filter(unit == my_unit) %>%
              sf::st_transform(crs = sf::st_crs(naip_st))
          , alpha = 0
          , lwd = 1.5
          , color = "orangered"
      ) +
      geom_sf(data = crowns_group %>%
                sf::st_crop(
                  rx_fire %>% dplyr::filter(unit == my_unit) %>%
                  sf::st_buffer(dist = 50) %>%
                  sf::st_bbox()
                ) %>%
                sf::st_transform(crs = sf::st_crs(naip_st))
          , lwd = NA
          , aes(fill = crown_group_class_color)
      ) +
      geom_sf(data = harvests_post_lidar %>%
                sf::st_union() %>% 
                sf::st_crop(
                  rx_fire %>% dplyr::filter(unit == my_unit) %>%
                  sf::st_buffer(dist = 50) %>%
                  sf::st_bbox()
                ) %>%
                sf::st_transform(crs = sf::st_crs(naip_st))
          , color = "blue"
          , lwd = 1.5
          , fill = (col_data %>% dplyr::filter(crown_group_class == "Post-Lidar Harvest"))$crown_group_class_color
          # , alpha = 0.4
      ) +
      labs(
        title = paste0("Rx Fire Unit: "
                       , my_unit
                       , "   ("
                       , scales::comma((rx_fire %>% dplyr::filter(unit == my_unit))$area_ha, accuracy = 1)
                       , " ha | "
                       , scales::comma((rx_fire %>% dplyr::filter(unit == my_unit))$area_m2/4047, accuracy = 1)
                       , " ac)"
                )
        , subtitle = ifelse(
          (rx_fire %>% dplyr::filter(unit == my_unit))$has_postlidar_harvest == 1
          , "**This unit has post-lidar timber harvest (blue boundary)"
          , ""
        )
      ) +
      xlab("") +
      ylab("") +
      scale_x_continuous(expand = c(0, 0)) +
      scale_y_continuous(expand = c(0, 0)) +
      theme_bw() +
      theme(
        legend.position = "none"
        , legend.direction = "horizontal"
        , legend.title = element_blank()
        , axis.text = element_text(size = 8)
        , panel.border = element_blank()
        , plot.title = element_text(size = 14, face = "bold", margin = margin(0,0,2,0))
        , plot.subtitle = element_text(size=9, face="bold.italic", color="blue", margin = margin(0,0,0,0))
      )
  )
}
# print(plot_cover_class_map(my_unit = rx_fire$unit[15]))
```

### Rx Fire Unit Contour

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
plot_contour_map <- function(my_unit){
  (
    #########################################
    #########################################
    # map of unit w/ contour
    #########################################
    #########################################
    # plot
    ggplot() +
      stars::geom_stars(data = bhef_elev[
        rx_fire %>% dplyr::filter(unit == my_unit) %>% 
        sf::st_buffer(dist = 50) %>% 
        sf::st_bbox()
      ]) +
      scale_fill_viridis_c(option = "viridis", alpha = 0.9, na.value = "transparent") +
      geom_sf(data = bhef_contour %>% 
        sf::st_crop(
          rx_fire %>% dplyr::filter(unit == my_unit) %>% 
          sf::st_buffer(dist = 50) %>% 
          sf::st_bbox()
        )
        , alpha = 0
        , lwd = 0.5
        , color = "gray30"
        , show.legend = FALSE
      ) +
      geom_sf(data = rx_fire %>%
              dplyr::filter(unit == my_unit)
          , alpha = 0
          , lwd = 1.5
          , color = "orangered"
          , show.legend = FALSE
      ) +
      labs(
        subtitle = paste0("Contour lines are at "
                          , as.character(contour_int_m)
                          , "-m (~"
                          , as.character(round(contour_int_m * 3.281, 1))
                          , "-ft) intervals"
          )
      ) +
      xlab("") +
      ylab("") +
      scale_x_continuous(expand = c(0, 0)) +
      scale_y_continuous(expand = c(0, 0)) +
      theme_bw() +
      theme(
        legend.position = "bottom"
        , legend.direction = "horizontal"
        , legend.margin = margin(0,0,0,0)
        , legend.box.margin = margin(-21,0,2,0)
        , legend.text = element_text(size = 7)
        , legend.title = element_text(size = 7)
        , axis.text.y = element_text(size = 7)
        , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7)
        , panel.border = element_blank()
        , plot.subtitle = element_text(size=9, face="italic", color="gray20", margin = margin(0,0,0,0))
      ) +
      guides(
        fill = guide_legend(title="Elev. (m)")
      )
  )
}
# print(plot_contour_map(my_unit = rx_fire$unit[10]))
```

### Rx Fire Unit Insert

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
plot_small_map <- function(my_unit){
  (
    ggplot() +
      geom_sf(data = bhef_boundary, alpha = 0, lwd = 1, color = "black", linetype = "dashed") +
      geom_sf(data = rx_fire, alpha = 0, lwd = 0.7, color = "orangered") +
      geom_sf(
        data = rx_fire %>% dplyr::filter(unit == my_unit)
        , fill = "black"
        , alpha = 0.2
        , lwd = 1.5
        , color = "orangered3"
      ) +
      geom_sf_label(
        data = rx_fire
        , aes(label = unit)
        , label.size = NA
        , alpha = 0
        , size = 2.5
      ) +
      xlab("") +
      ylab("") +
      scale_x_continuous(expand = c(0, 0)) +
      scale_y_continuous(expand = c(0, 0)) +
      theme_bw() +
      theme(
        axis.text = element_text(size = 5)
        , axis.text.x = element_text(angle = 35)
        , panel.border = element_blank()
      )

  )
}
# print(plot_small_map(my_unit = rx_fire$unit[11]))
```

## Rx Fire Info Sheets

Create info sheets for each Rx Fire unit.

```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# set up plot legend once
p_legend <- 
  ggplot(col_data) +
    geom_col(
      aes(
        x = row_n
        , y = 1
        , fill = crown_group_class
      )
    ) +
    scale_fill_manual(values = scale_fill_manual_values_fill) +
    geom_text(
      aes(
        x = row_n
        , y = 0.5
        , label = crown_group_class
      )
      , size = 2.5
      , fontface = "bold"
      , angle = 90
      , color = "black"
    ) +
    theme_nothing()

# loop through all units to create pdf export
for (i in 1:nrow(rx_fire)) {
# for (i in c(1,3)) {
  # plots
  p_class_map <-  plot_cover_class_map(my_unit = rx_fire$unit[i]) 
  p_class_bars <-  plot_cover_class_bars(my_unit = rx_fire$unit[i]) 
  p_contour_map <-  plot_contour_map(my_unit = rx_fire$unit[i]) 
  p_small_map <-  plot_small_map(my_unit = rx_fire$unit[i]) 
  # arrange plots on one page
  info_sht <-
  print(
    ggpubr::ggarrange(
      p_class_map
      , ggpubr::ggarrange(
        p_small_map
        , p_contour_map
        , p_class_bars
        , nrow = 1
        , ncol = 3
        , widths = c(0.5, 1.2, 1)
      )  
      , nrow = 2
      , ncol = 1
      , heights = c(1.7, 1)
      # , align = "hv"
    )
  )
  # export pdf
  # ggpubr::ggexport(
  #   info_sht
  #   , filename = paste0("../data/pdf/unit", rx_fire$unit[i],".pdf")
  #   , width = 1200
  #   , height = 675
  # )
  ggplot2::ggsave(
    filename = paste0("../data/pdf/unit", sprintf("%02d", as.numeric(rx_fire$unit[i])),".pdf")
    , plot = info_sht
    , width = 11
    , height = 8.5
    , units = "in"
    , dpi = "print"
  )
}

```


## Rx Fire Info Packet

Combine info sheets for each Rx Fire unit into full packet for printing.


```{r, warning=F, message=F, fig.width = 10, fig.height = 6}
# combine all pdfs together
pdfs <- sort(list.files("../data/pdf", pattern = "\\.pdf$", full.names = TRUE))

# combine with pdftools
pdftools::pdf_combine(
  pdfs
  , output = paste0(
    "../data/pdf/"
    , "BHEF_RxFire_Plan_"
    , gsub("-", "", Sys.Date())
    , ".pdf"
  )
)


```


<!--chapter:end:03_analysis_forestcov.Rmd-->

