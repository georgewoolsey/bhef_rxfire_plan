[["index.html", "Black Hills Experimental Forest Prescribed Fire Planning Chapter 1 Introduction", " Black Hills Experimental Forest Prescribed Fire Planning George Woolsey 2022-08-15 Chapter 1 Introduction My name is George Woolsey and I am currently employed by the United States Forest Service working with Dr. Mike Battaglia at the Rocky Mountain Research Station in Fort Collins, Colorado. In addition, I am pursuing a MS in Forest Sciences at Colorado State University (CSU). At CSU I am working with Dr. Wade Tinkham in the Forest Biometrics Lab. "],["objective.html", "Chapter 2 Objective", " Chapter 2 Objective The objective of this analysis is to describe the site conditions on the Black Hills Experimental Forest (North Dakota, USA) for planning future prescribed fire treatments. This analysis incorporates the spatial location of research plots and some of the measurements collected at those plots (e.g. Ritter et al. 2022). In ponderosa pine (Pinus ponderosa) forests, prescribed fires and wildfires burning under moderate conditions can effectively reduce fuel loading and restore the structures and complex spatial patterns that existed in these forests historically (Holden et al. 2007; Battaglia et al. 2008). In the ponderosa pine forests of the Black Hills, ladder fuels can develop quickly after a mechanical treatment if regeneration densities are not regulated. Prescribed fire can successfully maintain low regeneration densities following fuel treatments (Battaglia et al. 2008). In addition to reducing tree densities and surface fuel loads, prescribed fires can be used to improve nutrient cycling, increase forage plant production, and improve wildlife habitat (DeBano et al. 1998; Allen et al. 2002). "],["vector_data.html", "Chapter 3 Import Vector Data 3.1 National Forest Management data download 3.2 Load Research Plot data 3.3 Load Stem Map data 3.4 Load Rx Fire shapefile 3.5 Load National Forests shapefile 3.6 Load Experimental Forests shapefile 3.7 Load FACTS Timber Harvests 3.8 Join Research Plot to Harvest 3.9 Join Stem Map to Research Plot &amp; Harvest 3.10 Map Harvests, Research Plots, Stem Map 3.11 Write Out Data", " Chapter 3 Import Vector Data # turn off the s2 processing ## https://stackoverflow.com/questions/68478179/how-to-resolve-spherical-geometry-failures-when-joining-spatial-data sf::sf_use_s2(FALSE) 3.1 National Forest Management data download The Forest Activity Tracking System (FACTS) database maintained by the U.S. Department of Agriculture, Forest Service (USFS) used to delineate georeferenced boundaries of forest harvest activities. # check for data and download zip_path &lt;- c( &quot;https://data.fs.usda.gov/geodata/edw/edw_resources/fc/S_USA.NFSLandUnit.gdb.zip&quot; # forests boundaries , &quot;https://data.fs.usda.gov/geodata/edw/edw_resources/fc/S_USA.Experimental_Area_Boundaries.gdb.zip&quot; # exp forest boundaries # , &quot;https://data.fs.usda.gov/geodata/edw/edw_resources/fc/S_USA.Activity_TimberHarvest.gdb.zip&quot; # Timber Harvests # , &quot;https://data.fs.usda.gov/geodata/edw/edw_resources/shp/S_USA.Activity_HazFuelTrt_PL.zip&quot; # Hazardous Fuel Treatment Reduction # , &quot;https://data.fs.usda.gov/geodata/edw/edw_resources/shp/S_USA.Activity_SilvTSI.zip&quot; # SilvTSI (Silviculture Timber Stand Improvement) # , &quot;https://data.fs.usda.gov/geodata/edw/edw_resources/shp/S_USA.Activity_SilvReforestation.zip&quot; # SilvReforestation # , &quot;https://edcintl.cr.usgs.gov/downloads/sciweb1/shared/MTBS_Fire/data/composite_data/burned_area_extent_shapefile/mtbs_perimeter_data.zip&quot; ) for (i in 1:length(zip_path)) { f_nm &lt;- paste0( &quot;../data/&quot; , str_split(zip_path[i], &quot;/&quot;, simplify = TRUE)[length(str_split(zip_path[i], &quot;/&quot;, simplify = TRUE))] ) fldr &lt;- paste0(gsub(&quot;.zip&quot;, &quot;&quot;, f_nm)) options(timeout = 60 * 15) if(file.exists(fldr) == FALSE){ # download data if(file.exists(f_nm) == FALSE){ download.file(zip_path[i], destfile = f_nm) }else{print(&quot;file already exists&quot;)} # unzip unzip(f_nm, overwrite=TRUE, exdir = fldr) file.remove(f_nm) }else{print(&quot;unzip already exists&quot;)} } 3.2 Load Research Plot data Ritter et al. 2022 established eleven, 100x100 m (1-ha), plots within mechanical treatment units. Measurements occurred during the summer of 2017, which represented 3 years post-treatment for small group retention treatment and 4 years post-treatment for free selection-off, free selection-On, and commercial thinning treatments. In the free selection-off treatments, overstory trees were included in the spacing guidelines for precommercial thinning treatment. In the free selection-on treatments, overstory trees were not included in the spacing guidelines for precommercial thinning treatments resulting in residual precommercial trees potentially growing under the crown of an overstory tree. # load shapefile research_plots &lt;- sf::st_read(&quot;../data/Black_Hills_StemMaps.shp&quot;) %&gt;% dplyr::filter(sf::st_is_valid(.)) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) %&gt;% sf::st_buffer(dist = 50, endCapStyle = &quot;SQUARE&quot;) %&gt;% dplyr::mutate(area = sf::st_area(.)) #rename sf geom column names(research_plots)[names(research_plots)==tolower(attr(research_plots, &quot;sf_column&quot;))] = &quot;geometry&quot; sf::st_geometry(research_plots) = &quot;geometry&quot; # data structure of data research_plots %&gt;% glimpse() # plot does not uniquely identify record length(unique(research_plots$plot)) == nrow(research_plots) # create id research_plots &lt;- research_plots %&gt;% dplyr::group_by(plot) %&gt;% dplyr::mutate( plot_id = paste0(plot, &quot;_&quot;, as.character(dplyr::row_number())) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::relocate(plot_id) length(unique(research_plots$plot_id)) == nrow(research_plots) 3.3 Load Stem Map data Ritter et al. 2022 installed three plots in the commercial thin treatment and each of the two free selection treatments. Only two plots were installed in the small group retention treatment as it was smaller in area and was bisected by a powerline corridor that precluded the placement of more than two nonoverlapping plots. Each plot was subdivided into 16 25x25 m quadrats within which all live trees &gt;1.37 m tall had their x, y locations recorded. In addition to mapping their x, y location, all live trees were tagged and had their DBH, tree height (TH), compacted crown base height (CBH), crown width (CW), and species recorded. # load stem map shapefile stem_map &lt;- sf::st_read(&quot;../data/BHEF_stem_map.shp&quot;) %&gt;% dplyr::filter(sf::st_is_valid(.)) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) %&gt;% sf::st_transform(crs = sf::st_crs(research_plots)) ## Reading layer `BHEF_stem_map&#39; from data source ## `C:\\Data\\usfs\\bhef_rxfire_plan\\data\\BHEF_stem_map.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 1342 features and 19 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 607591.4 ymin: 4889665 xmax: 610681.1 ymax: 4893030 ## Projected CRS: WGS 84 / UTM zone 13N #rename sf geom column names(stem_map)[names(stem_map)==tolower(attr(stem_map, &quot;sf_column&quot;))] = &quot;geometry&quot; sf::st_geometry(stem_map) = &quot;geometry&quot; # data structure of stem map data stem_map %&gt;% glimpse() ## Rows: 1,342 ## Columns: 20 ## $ uidtree &lt;chr&gt; &quot;SQ_01_7_1272&quot;, &quot;SQ_01_7_1273&quot;, &quot;SQ_01_7_1274&quot;, &quot;SQ_01_7_12~ ## $ utmx &lt;dbl&gt; 607759.6, 607766.1, 607767.7, 607773.3, 607774.8, 607767.4,~ ## $ utmy &lt;dbl&gt; 4891801, 4891801, 4891805, 4891799, 4891800, 4891785, 48917~ ## $ unit &lt;chr&gt; &quot;SQ_01&quot;, &quot;SQ_01&quot;, &quot;SQ_01&quot;, &quot;SQ_01&quot;, &quot;SQ_01&quot;, &quot;SQ_01&quot;, &quot;SQ_0~ ## $ plot &lt;dbl&gt; 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,~ ## $ tag &lt;dbl&gt; 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281,~ ## $ status &lt;chr&gt; &quot;L&quot;, &quot;D&quot;, &quot;D&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;D&quot;, &quot;D&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;,~ ## $ gst &lt;chr&gt; &quot;G&quot;, NA, NA, NA, NA, &quot;G&quot;, &quot;G&quot;, NA, NA, NA, NA, NA, NA, NA, ~ ## $ species &lt;chr&gt; &quot;PIPO&quot;, &quot;PIPO&quot;, &quot;PIPO&quot;, &quot;BEPA&quot;, &quot;BEPA&quot;, &quot;PIPO&quot;, &quot;PIPO&quot;, &quot;PI~ ## $ count &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,~ ## $ dbhin &lt;dbl&gt; 17.4, 8.7, 11.9, 8.1, 6.2, 14.9, 15.5, 13.6, 8.9, 11.5, 12.~ ## $ dist &lt;dbl&gt; 57.6, 60.0, 74.1, 68.9, 74.6, 26.1, 29.1, 80.8, 65.8, 61.5,~ ## $ azm &lt;dbl&gt; 0, 21, 21, 41, 42, 82, 146, 178, 200, 209, 211, 218, 234, 2~ ## $ heightft &lt;dbl&gt; 69.8, 11.7, 14.3, 37.2, 18.9, 54.1, 63.4, 48.7, 14.4, 54.6,~ ## $ cbhft &lt;dbl&gt; 26.4, 0.0, 0.0, 7.3, 6.4, 22.9, 23.7, 0.0, 0.0, 20.4, 21.9,~ ## $ radialgrow &lt;dbl&gt; 12, 0, 0, 0, 0, 12, 15, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 24, ~ ## $ hgtgrowthf &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,~ ## $ comments &lt;chr&gt; NA, &quot;BROKEN TOP&quot;, &quot;BROKEN TOP&quot;, &quot;DEAD TOP&quot;, &quot;BROKEN TOP&quot;, N~ ## $ mpb &lt;chr&gt; &quot;no&quot;, &quot;no&quot;, &quot;no&quot;, &quot;no&quot;, &quot;no&quot;, &quot;no&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;yes&quot;, &quot;no~ ## $ geometry &lt;POINT [m]&gt; POINT (607759.6 4891801), POINT (607766.1 4891801), P~ 3.4 Load Rx Fire shapefile # load stem map shapefile rx_fire &lt;- sf::st_read(&quot;../data/ExpoRX.shp&quot;) %&gt;% dplyr::filter(sf::st_is_valid(.)) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) %&gt;% sf::st_transform(crs = sf::st_crs(research_plots)) ## Reading layer `ExpoRX&#39; from data source ## `C:\\Data\\usfs\\bhef_rxfire_plan\\data\\ExpoRX.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 20 features and 3 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 607447.8 ymin: 4888127 xmax: 610896.3 ymax: 4893405 ## Projected CRS: NAD83 / UTM zone 13N #rename sf geom column names(rx_fire)[names(rx_fire)==tolower(attr(rx_fire, &quot;sf_column&quot;))] = &quot;geometry&quot; sf::st_geometry(rx_fire) = &quot;geometry&quot; # data structure of stem map data rx_fire %&gt;% glimpse() ## Rows: 20 ## Columns: 4 ## $ id &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ## $ unit &lt;chr&gt; &quot;1&quot;, &quot;6&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;19&quot;, &quot;20&quot;, &quot;21&quot;, &quot;22~ ## $ acres &lt;int&gt; 59, 134, 155, 90, 53, 116, 38, 494, 594, 194, 206, 89, 341, 1~ ## $ geometry &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((609103.9 48..., MULTIPOLYGON (((608169.4 48..~ 3.5 Load National Forests shapefile # load forest boundary shapefile # extract file name f_path &lt;- paste0(&quot;../data&quot;, &quot;/&quot;, &quot;S_USA.NFSLandUnit.gdb&quot;, &quot;/&quot;) dta_nm &lt;- paste(f_path , list.files(f_path, pattern = &quot;\\\\.gdb$&quot;)[1] , sep = &quot;/&quot; ) lyr_nms &lt;- sf::st_layers(dsn = dta_nm)$name lyr &lt;- lyr_nms[grep(&quot;NFSLandUnit&quot;, lyr_nms)][1] # load in data forests &lt;- sf::st_read( dsn = dta_nm , layer = lyr , query = &quot;SELECT * FROM \\&quot;NFSLandUnit\\&quot; WHERE REGION NOT IN (&#39;08&#39;, &#39;09&#39;, &#39;10&#39;) AND NFSLANDUNITTYPE = &#39;National Forest&#39; &quot; ) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) #rename sf geom column names(forests)[names(forests)==tolower(attr(forests, &quot;sf_column&quot;))] = &quot;geometry&quot; sf::st_geometry(forests) = &quot;geometry&quot; # transform forests &lt;- forests %&gt;% sf::st_transform(crs = sf::st_crs(research_plots)) #make BHNF only dataset forests_bhnf &lt;- forests %&gt;% filter(region == &quot;02&quot; &amp; nffid == &quot;0471&quot;) 3.6 Load Experimental Forests shapefile # load boundary shapefile # extract file name f_path &lt;- paste0(&quot;../data&quot;, &quot;/&quot;, &quot;S_USA.Experimental_Area_Boundaries.gdb&quot;, &quot;/&quot;) dta_nm &lt;- paste(f_path , list.files(f_path, pattern = &quot;\\\\.gdb$&quot;)[1] , sep = &quot;/&quot; ) lyr_nms &lt;- sf::st_layers(dsn = dta_nm)$name lyr &lt;- lyr_nms[grep(&quot;Experimental_Area_Boundaries&quot;, lyr_nms)][1] # load in data exp_forests &lt;- sf::st_read( dsn = dta_nm , layer = lyr ) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) #rename sf geom column names(exp_forests)[names(exp_forests)==tolower(attr(exp_forests, &quot;sf_column&quot;))] = &quot;geometry&quot; sf::st_geometry(exp_forests) = &quot;geometry&quot; # transform exp_forests &lt;- exp_forests %&gt;% sf::st_transform(crs = sf::st_crs(research_plots)) # spatial join BHNF bhef_boundary &lt;- sf::st_intersection(forests_bhnf %&gt;% dplyr::select(nfslandunitid, nffid, nfslandunitname), exp_forests) 3.7 Load FACTS Timber Harvests Metadata file available here. Utilize data downloaded and created in Forest Management Impacts on Productivity project. This appendix includes a listing of all the active and inactive FACTS activity codes, as well as detailed descriptions of some of the codes. # load boundary shapefile harvests &lt;- sf::st_read(&quot;../data/harvests.gpkg&quot;) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) #rename sf geom column names(harvests)[names(harvests)==tolower(attr(harvests, &quot;sf_column&quot;))] = &quot;geometry&quot; sf::st_geometry(harvests) = &quot;geometry&quot; # transform harvests &lt;- harvests %&gt;% sf::st_transform(crs = sf::st_crs(research_plots)) # spatial join BHEF # bhef_harvests &lt;- sf::st_intersection( # bhef_boundary %&gt;% # dplyr::select(name, station, hectares, lead_scientist) %&gt;% # dplyr::rename_with(~ paste0(&quot;exp_forest_&quot;, .), -geometry) %&gt;% # # there are some plots outside of BHEF boundary # sf::st_buffer(2500) # , harvests) bhef_harvests &lt;- sf::st_intersection( # there are some plots outside of BHEF boundary sf::st_union( bhef_boundary , sf::st_as_sfc(sf::st_bbox(research_plots)) %&gt;% sf::st_transform(crs = sf::st_crs(research_plots)) ) %&gt;% dplyr::select(geometry) , harvests) # filter for last 15 years bhef_harvests_l15 &lt;- bhef_harvests %&gt;% dplyr::filter(year_id &gt;= year(Sys.time()) - 15 ) %&gt;% dplyr::mutate(lab &lt;- paste0(treatment_type_grp, &quot; (&quot;, as.character(year_id), &quot;)&quot;)) 3.7.1 Harvests by treatment type # data by treatment type bhef_harvests_l15 %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(activity_name) %&gt;% dplyr::summarise(n = n()) %&gt;% dplyr::arrange(desc(n)) %&gt;% ggplot(.) + geom_col(aes(y = reorder(activity_name, n), x = n, fill = n), width = 0.7) + geom_text( aes(y = reorder(activity_name, n), x =n, label = scales::comma(n, accuracy = 1)) , color = &quot;black&quot;, size = 4 , position = position_dodge(0.9) , hjust = -0.1 ) + labs( title = &quot;Number Harvests Completed by Treatment Type (last 15 years)&quot; , subtitle = &quot;within BHEF boundary and bounding box of research plot area&quot; ) + xlab(&quot;# Harvests&quot;) + ylab(&quot;Treatment&quot;) + scale_x_continuous(labels = scales::comma) + scale_fill_viridis_c(alpha = 0.7, option = &quot;cividis&quot;, direction = -1) + theme_bw() + theme( legend.position = &quot;none&quot; ) 3.8 Join Research Plot to Harvest # attach harvest data to research plots research_plots_harvests &lt;- sf::st_intersection( research_plots , bhef_harvests_l15 %&gt;% dplyr::select( activity_code , activity_name , treatment_type_grp , suid , date_compl , year_id ) %&gt;% # dplyr::filter(treatment_type_grp %in% c(&quot;Commercial Thinning&quot; # , &quot;Overstory Removal Cut&quot; # , &quot;Single-tree/Group Selection Cut&quot; # , &quot;Patch Clearcut&quot; # )) %&gt;% dplyr::rename_with(~ paste0(&quot;harvest_&quot;, .), -geometry) ) %&gt;% dplyr::mutate(harvest_plot_areamsq = as.numeric(sf::st_area(.))) %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(plot_id) %&gt;% dplyr::arrange( plot_id , desc(harvest_plot_areamsq) , harvest_date_compl ) %&gt;% dplyr::select( plot_id , dplyr::starts_with(&quot;harvest_&quot;) ) %&gt;% dplyr::mutate( row_n = dplyr::row_number() ) %&gt;% dplyr::ungroup() %&gt;% tidyr::pivot_wider( id_cols = plot_id , names_from = row_n , values_from = !c(plot_id, row_n) , names_sep = &quot;_&quot; ) # join to spatial data research_plots &lt;- research_plots %&gt;% left_join(research_plots_harvests, by = c(&quot;plot_id&quot;=&quot;plot_id&quot;)) remove(research_plots_harvests) 3.9 Join Stem Map to Research Plot &amp; Harvest # attach harvest data to stem map stem_map_harvests &lt;- sf::st_intersection( stem_map , bhef_harvests_l15 %&gt;% dplyr::select( activity_code , activity_name , treatment_type_grp , suid , date_compl , year_id ) %&gt;% dplyr::rename_with(~ paste0(&quot;harvest_&quot;, .), -geometry) ) %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(uidtree) %&gt;% dplyr::arrange( uidtree , harvest_date_compl ) %&gt;% dplyr::select( uidtree , dplyr::starts_with(&quot;harvest_&quot;) ) %&gt;% dplyr::mutate( row_n = dplyr::row_number() ) %&gt;% dplyr::ungroup() %&gt;% tidyr::pivot_wider( id_cols = uidtree , names_from = row_n , values_from = !c(uidtree, row_n) , names_sep = &quot;_&quot; ) # join to spatial data stem_map &lt;- stem_map %&gt;% left_join(stem_map_harvests, by = c(&quot;uidtree&quot;=&quot;uidtree&quot;)) # join to research plot data temp_stem_map &lt;- sf::st_intersection( stem_map %&gt;% dplyr::select(uidtree) , research_plots %&gt;% dplyr::select(plot_id, trt, harvest_activity_name_1, harvest_year_id_1, harvest_treatment_type_grp_1) %&gt;% dplyr::rename_with(~ paste0(&quot;rplot_&quot;, .), -geometry) ) %&gt;% sf::st_set_geometry(NULL) stem_map &lt;- stem_map %&gt;% left_join(temp_stem_map, by = c(&quot;uidtree&quot;=&quot;uidtree&quot;)) remove(list = c(&quot;stem_map_harvests&quot;, &quot;temp_stem_map&quot;)) 3.9.1 Stem Map Descriptive statistics. # descriptive stats kable(stem_map %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by( unit , harvest_activity_name_1 ) %&gt;% dplyr::summarise( # plots = dplyr::n_distinct(plot) trees = dplyr::n_distinct(uidtree) , min_DBHin = min(dbhin) , max_DBHin = max(dbhin) , mean_DBHin = mean(dbhin) , QMDin = sqrt( sum(dbhin*dbhin) / n() ) , min_HTft = min(heightft) , max_HTft = max(heightft) , mean_HTft = mean(heightft) , stdev_HTft = sd(heightft) ) %&gt;% dplyr::arrange(unit, desc(trees)) , format = &quot;html&quot; , caption = &quot;Tree Measurement Descriptive Statistics by Unit &amp; Treatment&quot; , digits = 1 , col.names = c( &quot;unit&quot; , &quot;treatment&quot; # , &quot;# plots&quot; , &quot;# trees&quot; , &quot;min&quot; , &quot;max&quot; , &quot;mean&quot; , &quot;QMD&quot; , &quot;min&quot; , &quot;max&quot; , &quot;mean&quot; , &quot;st.dev.&quot; ) , align=rep(&#39;c&#39;, 5) ) %&gt;% # kable_classic() %&gt;% add_header_above(c(&quot; &quot; = 3, &quot;DBH (in.)&quot; = 3, &quot;QMD (in.)&quot; = 1, &quot;Height (ft.)&quot; = 4)) %&gt;% kable_material(c(&quot;striped&quot;, &quot;hover&quot;)) %&gt;% # column_spec(., 2, width = &quot;20em&quot;) %&gt;% kable_styling(font_size = 11) Table 3.1: Tree Measurement Descriptive Statistics by Unit &amp; Treatment DBH (in.) QMD (in.) Height (ft.) unit treatment # trees min max mean QMD min max mean st.dev. SQ_01 Single-tree Selection Cut 63 3.1 18.6 10.7 11.7 10.1 72.6 42.6 22.5 SQ_01 Commercial Thin 11 4.6 15.4 12.0 12.3 29.8 66.5 56.8 10.2 SQ_02 Single-tree Selection Cut 215 0.4 19.2 7.3 8.1 4.8 67.9 33.6 15.4 SQ_02 NA 1 1.2 1.2 1.2 1.2 8.4 8.4 8.4 NA SQ_03 Single-tree Selection Cut 163 0.2 15.7 5.4 7.3 0.7 63.4 24.3 20.3 SQ_05 Single-tree Selection Cut 174 0.3 22.1 7.7 9.3 4.6 73.1 32.3 19.0 SQ_06 Single-tree Selection Cut 142 3.0 24.0 8.4 10.2 11.4 81.9 38.8 21.4 SQ_07 Single-tree Selection Cut 62 3.8 16.0 12.0 12.2 16.7 68.0 53.4 9.7 SQ_14 NA 251 0.1 15.3 5.7 7.5 4.5 66.7 29.5 21.0 SQ_14 Commercial Thin 1 8.2 8.2 8.2 8.2 41.1 41.1 41.1 NA SQ_20 Single-tree Selection Cut 150 0.3 23.4 5.4 7.8 4.8 80.2 26.3 23.6 SQ_23 Single-tree Selection Cut 109 0.2 19.9 8.3 9.6 4.6 64.8 34.0 16.8 3.10 Map Harvests, Research Plots, Stem Map # make map # different background map types: https://leaflet-extras.github.io/leaflet-providers/preview/ # names(leaflet.providers::providers_loaded()$providers) mapviewOptions(homebutton = FALSE, basemaps = c(&quot;Esri&quot;)) # map mapview(bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) + mapview(bhef_harvests_l15 , zcol = &quot;treatment_type_grp&quot; , col.regions = viridis::viridis(n=length(unique(bhef_harvests_l15$treatment_type_grp))) , alpha.regions = 0.6 , label = c(&quot;lab&quot;) , legend = FALSE , popup = popupTable( bhef_harvests_l15 , zcol = c( &quot;year_id&quot; , &quot;treatment_type_grp&quot; , &quot;activity_name&quot; ) , row.numbers = FALSE , feature.id = FALSE ) ) + mapview(rx_fire , color = &quot;red&quot; , lwd = 2 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) + mapview(research_plots , zcol = &quot;trt&quot; , col.regions = viridis::mako(n=length(unique(research_plots$trt)), direction = -1) , lwd = 2 , col = &quot;gray90&quot; , alpha.regions = 0.8 , label = c(&quot;trt&quot;) , legend = FALSE , popup = popupTable( research_plots , zcol = c( &quot;plot&quot; , &quot;trt&quot; , &quot;harvest_activity_name_1&quot; , &quot;harvest_year_id_1&quot; ) , row.numbers = FALSE , feature.id = FALSE ) ) + mapview(stem_map , zcol = &quot;unit&quot; , col.regions = viridis::turbo(n=length(unique(stem_map$unit)), alpha = 0.8) # RColorBrewer::brewer.pal(n = length(unique(stem_map$unit)), name = &quot;RdYlBu&quot;) , cex = 3.5 , label = c(&quot;unit&quot;) , legend = FALSE , popup = popupTable( stem_map , zcol = c( &quot;unit&quot; , &quot;plot&quot; , &quot;species&quot; , &quot;tag&quot; , &quot;heightft&quot; , &quot;dbhin&quot; , &quot;harvest_activity_name_1&quot; , &quot;harvest_year_id_1&quot; ) , row.numbers = FALSE , feature.id = FALSE ) ) Note, only harvests in last 15 years shown 3.11 Write Out Data # save cleaned data for reading to R later sf::st_write(forests_bhnf, &quot;../data/forests_bhnf.gpkg&quot;, append = FALSE) sf::st_write(bhef_boundary, &quot;../data/bhef_boundary.gpkg&quot;, append = FALSE) sf::st_write(bhef_harvests, &quot;../data/bhef_harvests.gpkg&quot;, append = FALSE) sf::st_write(research_plots, &quot;../data/research_plots.gpkg&quot;, append = FALSE) sf::st_write(stem_map, &quot;../data/stem_map.gpkg&quot;, append = FALSE) sf::st_write(rx_fire, &quot;../data/rx_fire.gpkg&quot;, append = FALSE) "],["lidar_data.html", "Chapter 4 Analyze Lidar Data 4.1 Overwrite Data Switch 4.2 Download Lidar Data From Natl Map 4.3 Load Vector Data 4.4 Load Elevation Data 4.5 Lidar Data Processing 4.6 Lidar-Derived Crown Groups Summary 4.7 Map Crowns and Rx Fire Area 4.8 Write Out Data", " Chapter 4 Analyze Lidar Data # turn off the s2 processing ## https://stackoverflow.com/questions/68478179/how-to-resolve-spherical-geometry-failures-when-joining-spatial-data sf::sf_use_s2(FALSE) 4.1 Overwrite Data Switch ####################################################### ####################################################### # TURN ON/OFF DATA OVERWRITE # TURNING THIS ON WILL RE-RUN ALL LIDAR PROCESSING # WHICH TAKES A LONG TIME ####################################################### ####################################################### overwrite_it &lt;- FALSE 4.2 Download Lidar Data From Natl Map The USGS National Map was used to obtain a list of file download links for Elevation Source Data (3DEP) - Lidar, IfSAR data available marked as Lidar Point Cloud (LPC). This download file list was placed in the data folder where the code below utilizes it to download data. The thumbnail option in the Natl Map was used to determine that the Fugro data will suffice to cover the BHEF area. Also, downloaded NAIP imagery and 3dep elevation while had ROI drawn in Natl Map. ####################################################### ####################################################### # download lidar data ####################################################### ####################################################### # open download text file urls &lt;- read.delim(&quot;../data/usgs_lidar_data.txt&quot;, header = FALSE) %&gt;% dplyr::rename(url_path = 1) %&gt;% dplyr::filter(grepl(&quot;FUGRO&quot;, toupper(url_path)) == TRUE) %&gt;% dplyr::mutate( orig_fname = word(gsub(&quot;/&quot;, &quot; &quot;, url_path), -1) , fname_sans_typ = gsub(&quot;.laz&quot;, &quot;&quot;, orig_fname) ) # create parent directory for data hey_dir &lt;- &quot;../data/lidar/&quot; if(dir.exists(hey_dir)==FALSE){ dir.create(hey_dir) } #loop through to download lidar data for(i in 1:nrow(urls)){ # set up names f_nm &lt;- paste0(hey_dir , urls$orig_fname[i] ) options(timeout = 60 * 15) ######################## ## download and unzip ######################## if(file.exists(f_nm)==FALSE){ # download download.file(urls$url_path[i], destfile = f_nm) }else{ print(paste0(f_nm, &quot; file already exists&quot;)) } } 4.3 Load Vector Data Spatial data was loaded and cleaned in prior chapter. # save cleaned data for reading to R later forests_bhnf &lt;- sf::st_read(&quot;../data/forests_bhnf.gpkg&quot;) bhef_boundary &lt;- sf::st_read(&quot;../data/bhef_boundary.gpkg&quot;) bhef_harvests &lt;- sf::st_read(&quot;../data/bhef_harvests.gpkg&quot;) research_plots &lt;- sf::st_read(&quot;../data/research_plots.gpkg&quot;) stem_map &lt;- sf::st_read(&quot;../data/stem_map.gpkg&quot;) rx_fire &lt;- sf::st_read(&quot;../data/rx_fire.gpkg&quot;) if(file.exists(&quot;../data/crowns_group.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ crowns_group &lt;- sf::st_read(&quot;../data/crowns_group.gpkg&quot;) } if(file.exists(&quot;../data/tree_tops.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ tree_tops &lt;- sf::st_read(&quot;../data/tree_tops.gpkg&quot;) } if(file.exists(&quot;../data/chm.tif&quot;) == TRUE &amp; overwrite_it == FALSE){ chm &lt;- stars::read_stars(&quot;../data/chm.tif&quot;) } 4.4 Load Elevation Data The USGS National Map was used to obtain a list of file download links for Elevation Source Data (3DEP) - Lidar, IfSAR data available marked as Lidar Point Cloud (LPC). This download file list was placed in the data folder where the code below utilizes it to download data. Using elevatr::get_elev_raster to get a digital elevation model (DEM) raster (~6.8m resolution) as a backup. # read in elevation data # z =14 is highest resolution (~6.8m) if(file.exists(&quot;../data/bhef_elev.tif&quot;) == FALSE){ elev &lt;- elevatr::get_elev_raster(bhef_boundary, z = 14) # sf::st_crs(elev) == sf::st_crs(bhef_boundary) bhef_elev &lt;- stars::st_as_stars(elev) # sf::st_transform(crs = sf::st_crs(bhef_boundary)) # save stars::write_stars(bhef_elev, &quot;../data/bhef_elev.tif&quot;, append = FALSE) }else{ bhef_elev &lt;- stars::read_stars(&quot;../data/bhef_elev.tif&quot;) } 4.4.1 Elevation plot # plot ggplot() + stars::geom_stars(data = bhef_elev[bhef_boundary]) + scale_fill_viridis_c(option = &quot;cividis&quot;, alpha = 0.9, na.value = &quot;transparent&quot;) + labs( title = &quot;BHEF Elevation Map&quot; , subtitle = sf::st_crs(bhef_elev)$input ) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme( axis.text = element_text(size = 8) # , panel.grid = element_blank() , panel.border = element_blank() ) + guides( fill = guide_legend(title=&quot;Elev. (m)&quot;) ) 4.5 Lidar Data Processing Use the lidR package for manipulating and visualizing point cloud data. See the very helpful book by Roussel, J.R., Goodbody, T.R.H., and Tompalski P. (2021) for more information. if(file.exists(&quot;../data/crowns_group.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ print(&quot;Proceeding to next section without processing or overwriting data...&quot;) }else{ # list laz files lazs &lt;- list.files(&quot;../data/lidar/&quot;, pattern = &quot;\\\\.laz$&quot;, full.names = TRUE) # change projection of DEM # # creating a new regular grid in a new CRS # newgrid &lt;- bhef_boundary %&gt;% # sf::st_transform(crs = sf::st_crs( lidR::readLAS(lazs[1], select = &quot;xyz&quot;) )) %&gt;% # sf::st_bbox() %&gt;% # stars::st_as_stars() # # set up old grid to warp back # oldgrid &lt;- bhef_boundary %&gt;% # sf::st_bbox() %&gt;% # stars::st_as_stars() # # warping the old raster to the new grid # bhef_elev_reproj &lt;- bhef_elev %&gt;% # stars::st_warp(newgrid) bhef_elev_reproj &lt;- bhef_elev %&gt;% stars::st_warp(crs = sf::st_crs( lidR::readLAS(lazs[1], select = &quot;xyz&quot;) )) ###################################################### # read laz files ###################################################### # If several files are read at once the returned LAS object is considered as one LAS file. # las &lt;- lidR::readLAS(lazs[2], select = &quot;xyz&quot;) # load XYZ only las &lt;- lidR::readLAS(lazs, select = &quot;xyz&quot;) # load XYZ only # lidR::las_check(las) # remove duplicate points las &lt;- lidR::filter_duplicates(las) # lidR::las_check(las) # summary(las$Z) # sf::st_crs(las) # temp_plot &lt;- plot(las, color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;) # temp_plot # # add_treetops3d(temp_plot, tree_tops) ###################################################### # remove outliers ###################################################### # Use Statistical Outliers Removal (SOR) # k = number of neighbors # m = multiplier in : avg distance + m * std deviation las &lt;- lidR::classify_noise(las, sor(k = 15, m = 7)) # plot(las, color = &quot;Classification&quot;, bg = &quot;white&quot;, size = 3) # Remove outliers using filter_poi() las &lt;- lidR::filter_poi(las, Classification != LASNOISE) # plot(las, color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;) # #repeat process with Isolated Voxels Filter IVF # las &lt;- lidR::classify_noise(las, ivf(res = 5, n = 6)) # # plot(las, color = &quot;Classification&quot;, bg = &quot;white&quot;, size = 3) # # Remove outliers using lidR::filter_poi() # las &lt;- lidR::filter_poi(las, Classification != LASNOISE) # plot(las, color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;) # ##################################################### # Ground classification # !!!!!!!!!!!!!!!!!!!!!!!!!! This is computationally intensive :&#39;( # ##################################################### # ################################################## # Progressive Morphological Filter The implementation of PMF algorithm in lidR # is based on the method described in Zhang et al. (2003) # ################################################## # # # b numeric. This is the parameter b in Zhang et al. (2003) (eq. 4 and 5). # # # dh0 numeric. This is dh0 in Zhang et al. (2003) (eq. 7). # # # dhmax numeric. This is dhmax in Zhang et al. (2003) (eq. 7). # # # s numeric. This is s in Zhang et al. (2003) (eq. 7). # # # max_ws numeric. Maximum window size to be used in filtering ground returns. This # # # limits the number of windows created. # # # exp logical. The window size can be increased linearly or exponentially (eq. 4 or 5). # # lidR::util_makeZhangParam( # # b = 2, # # dh0 = 0.2, # # dhmax = 210, # # s = 1.2, # # max_ws = 20, # # exp = FALSE # # ) # las &lt;- lidR::classify_ground(las, algorithm = pmf( # ws = lidR::util_makeZhangParam()$ws # , th = lidR::util_makeZhangParam()$th # ) # ) } 4.5.1 Height normalization using DEM Height normalization using the DEM loaded above subtacts the height of the ground surface from the point cloud at the resolution of the DEM raster data. The resulting normalized point cloud data classifies ground points at 0 meter in height (Z) and all points &gt;0 meters in height is assumed to be non-ground surface cover. if(file.exists(&quot;../data/crowns_group.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ print(&quot;Proceeding to next section without processing or overwriting data...&quot;) }else{ ###################################################### # Height normalization using DEM # could create own DEM with lidar data ... # but will use out of the box product for now ###################################################### # subtract DEM from lidar returns nlas &lt;- las - bhef_elev_reproj # correct for below ground returns nlas@data$Z &lt;- ifelse( ceiling(nlas@data$Z) == 0 | floor(nlas@data$Z) == 0 | nlas@data$Z &lt;= 0 , 0, nlas@data$Z ) # nlas &lt;- filter_poi(nlas, Z &gt;= 0) # remove below ground points nlas@data$Z &lt;- ifelse(nlas@data$Z &lt;= 0, 0, nlas@data$Z) # update classification nlas@data$Classification &lt;- ifelse(nlas@data$Z==0, 2, nlas@data$Classification) # filter out top 0.2% heights nlas &lt;- filter_poi(nlas, Z &lt;= stats::quantile((nlas@data %&gt;% dplyr::filter(Classification==1))$Z, 0.998)) # plot(nlas, color = &quot;Z&quot;, breaks = &quot;pretty&quot;, bg = &quot;white&quot;) # summary(nlas$Z) # table(nlas$Classification) # ###################################################### # # Height normalization using point cloud interpolation # # !!!!!! must run ground classification above first # ###################################################### # # point cloud normalization using interpolation # nlas &lt;- normalize_height(las, knnidw()) # # plot(nlas, color = &quot;Z&quot;, breaks = &quot;pretty&quot;, bg = &quot;white&quot;) # # plot(lidR::filter_ground(nlas), color = &quot;Classification&quot;, bg = &quot;white&quot;) # # summary(nlas$Z) # # table(nlas$Classification) ###################################################### # descriptive stats ###################################################### kable(nlas@data %&gt;% dplyr::group_by( Classification ) %&gt;% dplyr::summarise( # plots = dplyr::n_distinct(plot) points = dplyr::n() , min_z = min(Z) , max_z = max(Z) , mean_z = mean(Z) , median_z = median(Z) , stdev_z = sd(Z) ) %&gt;% dplyr::arrange(Classification) %&gt;% dplyr::mutate( Classification = dplyr::case_when( Classification == 1 ~ &quot;Surface&quot; , Classification == 2 ~ &quot;Ground&quot; , TRUE ~ &quot;Other&quot; ) ) , format = &quot;html&quot; , caption = &quot;Point Cloud Summary Statistics for Return Height (Z)&quot; , digits = 1 , col.names = c( &quot;Classification&quot; , &quot;points&quot; , &quot;min&quot; , &quot;max&quot; , &quot;mean&quot; , &quot;median&quot; , &quot;st.dev.&quot; ) , align=rep(&#39;c&#39;, 5) ) %&gt;% # kable_classic() %&gt;% add_header_above(c(&quot; &quot; = 2, &quot;Point Return Height (m)&quot; = 5)) %&gt;% kable_material(c(&quot;striped&quot;, &quot;hover&quot;)) %&gt;% # column_spec(., 2, width = &quot;20em&quot;) %&gt;% kable_styling(font_size = 11) # ggplot() + geom_histogram(data = (nlas@data %&gt;% dplyr::filter(Classification == 1)), aes(Z), binwidth = 1) } 4.5.2 Canopy Height model Points-to-raster algorithm with a resolution of 1 meter. For each pixel of the output raster the function attributes the height of the highest point found in the pixel from the point cloud. if(file.exists(&quot;../data/crowns_group.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ print(&quot;Proceeding to next section without processing or overwriting data...&quot;) }else{ ###################################################### # Canopy Height model ###################################################### # Points-to-raster algorithm with a resolution of 1 meter chm &lt;- lidR::rasterize_canopy( nlas , res = 1 # for each pixel of the output raster the function attributes the height of the highest point found , p2r(subcircle = 0.0 # , na.fill = tin() , na.fill = knnidw( k = 10 , p = 2 , rmax = 5 ) ) , pkg = &quot;terra&quot; ) # smooth chm pixels with median value in 3x3 matrix kernel &lt;- matrix(1,3,3) chm_smooth &lt;- terra::focal(chm, w = kernel, fun = median, na.rm = TRUE) %&gt;% stars::st_as_stars() %&gt;% stars::st_warp(crs = sf::st_crs(bhef_boundary)) # %&gt;% # sf::st_transform(crs = sf::st_crs(bhef_boundary)) # non smoothed chm &lt;- chm %&gt;% stars::st_as_stars() %&gt;% stars::st_warp(crs = sf::st_crs(bhef_boundary)) } 4.5.2.1 CHM plot # plot ggplot() + stars::geom_stars(data = chm[rx_fire %&gt;% dplyr::slice_head(n = 1)]) + # geom_sf(data = sf::st_crop(bhef_boundary, sf::st_bbox(chm_smooth)), alpha = 0, lwd = 0) + geom_sf(data = rx_fire %&gt;% dplyr::slice_head(n = 1), alpha = 0, lwd = 1, color = &quot;orangered&quot;) + scale_fill_viridis_c(option = &quot;mako&quot;, alpha = 0.9, na.value = &quot;transparent&quot;) + labs( title = &quot;BHEF Canopy Height Model&quot; , subtitle = paste0(&quot;sample Rx fire unit (&quot;, sf::st_crs(chm)$input, &quot;)&quot;) ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme( # legend.position = &quot;bottom&quot; # , legend.direction = &quot;horizontal&quot; axis.text = element_text(size = 8) # , panel.grid = element_blank() , panel.border = element_blank() ) + guides( fill = guide_legend(title=&quot;Hgt. (m)&quot;) ) 4.5.3 Individual Tree Detection (ITD) Local maximum filtering (LMF) with variable window size. Points below 2 m will equate to a window size of 3 m, while points above 20 meters equate to a window size of 5 m. Anything between 2 and 20 meter will have a non-linear relationship. if(file.exists(&quot;../data/crowns_group.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ print(&quot;Proceeding to next section without processing or overwriting data...&quot;) }else{ ###################################################### # Individual Tree Detection (ITD) ###################################################### # local maximum filtering (LMF) with variable window size # points below 2 m will equate to a window size of 3 m, # while points above 20 meters equate to a window size of 5 m. # Anything between 2 and 20 meter will have a non-linear relationship # define variable window function ws_fn &lt;- function(x) { y &lt;- 2.6 * (-(exp(-0.08*(x-2)) - 1)) + 3 y[x &lt; 2] &lt;- 3 y[x &gt; 20] &lt;- 5 return(y) } # ITD on CHM tree_tops &lt;- lidR::locate_trees(chm_smooth, lmf(ws = ws_fn)) %&gt;% # create classes based on Steel et al. 2021 dplyr::mutate( tree_class = dplyr::case_when( Z &gt; 8 ~ 3 # canopy , Z &gt;= 2 ~ 2 # subcanopy , Z &gt;= 1 ~ 1 # understory , TRUE ~ 0 # ground ) ) } 4.5.3.1 Tree Tops plot # plot ggplot() + stars::geom_stars(data = chm[rx_fire %&gt;% dplyr::slice_head(n = 1)]) + geom_sf(data = rx_fire %&gt;% dplyr::slice_head(n = 1), alpha = 0, lwd = 1, color = &quot;orangered&quot;) + geom_sf(data = sf::st_intersection(tree_tops, rx_fire %&gt;% dplyr::slice_head(n = 1)) , color = viridis::viridis(n=1, direction = -1), alpha = 0.7, shape = &quot;.&quot; ) + scale_fill_viridis_c(option = &quot;mako&quot;, alpha = 0.9, na.value = &quot;transparent&quot;) + labs( title = &quot;BHEF Canopy Height Model with Tree Tops Identified (yellow)&quot; , subtitle = paste0(&quot;sample Rx fire unit (&quot;, sf::st_crs(chm)$input, &quot;)&quot;) ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme_bw() + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme( axis.text = element_text(size = 8) # , panel.grid = element_blank() , panel.border = element_blank() ) + guides( fill = guide_legend(title=&quot;Hgt. (m)&quot;) ) # hey_plot &lt;- plot(nlas, color = &quot;Z&quot;, breaks = &quot;pretty&quot;, bg = &quot;white&quot;) # add_treetops3d(hey_plot, tree_tops &lt;- lidR::locate_trees(chm_smooth, lmf(ws = ws_fn)), col = &quot;black&quot;) # ?lidR::pixel_metrics() 4.5.3.2 Distribution of Tree Top Heights ###################################################### # height range of tree tops ###################################################### tree_tops %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::mutate(height_ceil = ceiling(Z)) %&gt;% dplyr::group_by(height_ceil) %&gt;% dplyr::summarise(n = n()) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( pct_tot = n / sum(n) ) %&gt;% ggplot(.) + # geom_col(aes(x = height_ceil, y = n, fill = n)) + geom_bar(aes(x = height_ceil, y = pct_tot, fill = n), color = &quot;gray25&quot;, stat = &quot;identity&quot;) + scale_y_continuous(labels = scales::label_percent(accuracy = 1L)) + scale_x_continuous(breaks = seq(min(tree_tops$Z), max(tree_tops$Z)+1, 1))+ scale_fill_viridis_c(alpha = 0.9, option = &quot;mako&quot;, direction = -1) + labs( title = &quot;Distribution of Tree Top Heights (m)&quot; ) + xlab(&quot;Tree Height (m) Bin&quot;) + ylab(&quot;% Tree tops&quot;) + theme_bw() + theme( legend.position=&quot;none&quot; ) 4.5.4 Individual Tree Crown (ITC) Segmentation Segment the canopy height model raster grid as individual tree crowns (ITC). Following the seeds + growing region algorithm described by Dalponte and Coomes (2016) to create a vector representation of tree crowns. Then using the individual tree crowns to create groupings and summary statistics of height for each interconnected crown group. if(file.exists(&quot;../data/crowns_group.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ print(&quot;Proceeding to next section without processing or overwriting data...&quot;) }else{ ###################################################### # Individual Tree Segmentation (ITS) ###################################################### # implements an algorithm for tree segmentation based on # Dalponte and Coomes (2016) algorithm (see reference). # This is a seeds + growing region algorithm. algo &lt;- lidR::dalponte2016( chm = chm , treetops = tree_tops # Threshold below which a pixel cannot be a tree , th_tree = 2 # Pixel is added to a region if its height is greater than the tree height multiplied by this value. , th_seed = 0.45 # Pixel is added to a region if its height is greater than the current # mean height of the region multiplied by this value. , th_cr = 0.55 # Maximum value of the crown diameter of a detected tree (in pixels) , max_cr = 10 # If treetops contains an attribute with the ID for each tree, the name of this attribute , ID = &quot;treeID&quot; ) crowns_st &lt;- algo() # quick plot # plot(crowns_st, col = lidR::pastel.colors(200), main = &quot;Individual Tree Crowns&quot;) # transform crowns stars object to vector data crowns_sf &lt;- crowns_st %&gt;% # convert to vector data and merge polygons with identical pixel values sf::st_as_sf(as_points = FALSE, merge = TRUE) %&gt;% # transform to same crs as rest of data sf::st_transform(crs = st_crs(bhef_boundary)) %&gt;% dplyr::mutate( tree_id = values , crown_area = sf::st_area(.) ) %&gt;% dplyr::relocate(tree_id, crown_area) %&gt;% dplyr::select(tree_id, crown_area) %&gt;% sf::st_set_precision(1e7) %&gt;% sf::st_make_valid(.) %&gt;% dplyr::filter(sf::st_is_valid(.)) # combine crown groups crowns_group &lt;- sf::st_cast( sf::st_union(crowns_sf) , &quot;POLYGON&quot;) # quick plot # plot(crowns_group, col = lidR::pastel.colors(200), main = &quot;Tree Crown Groups&quot;) #create id column crowns_group &lt;- crowns_group %&gt;% merge(., data.frame(geo_type = sf::st_geometry_type(crowns_group)), by.x=0, by.y=0, all.x=TRUE) %&gt;% dplyr::mutate(crown_group_id = as.numeric(as.factor(Row.names))) %&gt;% dplyr::select(-c(geo_type, Row.names)) %&gt;% dplyr::relocate(crown_group_id) %&gt;% sf::st_as_sf(., sf_column_name = &quot;geometry&quot;, crs = sf::st_crs(bhef_boundary)) # join back to individual tree crowns and summarize crowns_group_sum &lt;- sf::st_intersection(tree_tops, crowns_group) %&gt;% # if need to keep group at tree level... break here sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(crown_group_id) %&gt;% dplyr::summarise( count_trees = dplyr::n_distinct(treeID) , min_hgt_m = min(Z, na.rm = TRUE) , max_hgt_m = max(Z, na.rm = TRUE) , mean_hgt_m = mean(Z, na.rm = TRUE) , median_hgt_m = median(Z, na.rm = TRUE) , median_hgt_m = median(Z, na.rm = TRUE) , quant10_hgt_m = as.numeric( quantile(Z, probs = .10, na.rm = TRUE) ) , quant25_hgt_m = as.numeric( quantile(Z, probs = .25, na.rm = TRUE) ) , quant50_hgt_m = as.numeric( quantile(Z, probs = .50, na.rm = TRUE) ) , quant75_hgt_m = as.numeric( quantile(Z, probs = .75, na.rm = TRUE) ) , quant90_hgt_m = as.numeric( quantile(Z, probs = .90, na.rm = TRUE) ) , count_trees_canopy = sum(ifelse(tree_class == 3, 1, 0), na.rm = TRUE) , count_trees_subcanopy = sum(ifelse(tree_class == 2, 1, 0), na.rm = TRUE) , count_trees_understory = sum(ifelse(tree_class == 1, 1, 0), na.rm = TRUE) , count_trees_ground = sum(ifelse(tree_class == 0, 1, 0), na.rm = TRUE) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::arrange(crown_group_id) %&gt;% dplyr::mutate( crown_group_class = dplyr::case_when( count_trees == 1 ~ &quot;Individual Tree&quot; , count_trees &lt;= 10 &amp; count_trees_canopy/count_trees &gt;= .75 ~ &quot;Small Group - Canopy&quot; , count_trees &lt;= 10 &amp; count_trees_subcanopy/count_trees &gt;= .75 ~ &quot;Small Group - Subcanopy&quot; , count_trees &lt;= 10 ~ &quot;Small Group - Mixed&quot; , count_trees &lt;= 40 &amp; count_trees_canopy/count_trees &gt;= .75 ~ &quot;Medium Group - Canopy&quot; , count_trees &lt;= 40 &amp; count_trees_subcanopy/count_trees &gt;= .75 ~ &quot;Medium Group - Subcanopy&quot; , count_trees &lt;= 40 ~ &quot;Medium Group - Mixed&quot; , count_trees_canopy/count_trees &gt;= .75 ~ &quot;Continuous - Canopy&quot; , count_trees_subcanopy/count_trees &gt;= .75 ~ &quot;Continuous - Subcanopy&quot; , TRUE ~ &quot;Continuous - Mixed&quot; ) ) #attach summary statistics to spatial crown groups crowns_group &lt;- crowns_group %&gt;% dplyr::left_join(crowns_group_sum, by = c(&quot;crown_group_id&quot; = &quot;crown_group_id&quot;)) %&gt;% dplyr::mutate( crown_group_area_ha = as.numeric(sf::st_area(.)) / 10000 , trees_per_ha = count_trees / crown_group_area_ha ) } 4.6 Lidar-Derived Crown Groups Summary # plot ggplot() + geom_sf(data = sf::st_intersection(crowns_group, rx_fire %&gt;% dplyr::slice_head(n = 1)) , aes(fill = crown_group_class) , lwd = 0 ) + geom_sf(data = rx_fire %&gt;% dplyr::slice_head(n = 1), alpha = 0, lwd = 1, color = &quot;orangered&quot;) + scale_fill_viridis_d(option = &quot;turbo&quot;, alpha = 0.9) + labs( title = &quot;BHEF Crown Groups Classes&quot; , subtitle = paste0(&quot;sample Rx fire unit (&quot;, sf::st_crs(crowns_group)$input, &quot;)&quot;) ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme( legend.position = &quot;bottom&quot; , legend.title = element_blank() , axis.text = element_text(size = 8) # , panel.grid = element_blank() , panel.border = element_blank() ) 4.6.1 Crown Group Summary Statistics # table kable(crowns_group %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by( crown_group_class ) %&gt;% dplyr::summarise( # plots = dplyr::n_distinct(plot) crown_groups = dplyr::n() , mean_m2 = mean(crown_group_area_ha, na.rm = TRUE) * 10000 , trees_per_ha = mean(trees_per_ha, na.rm = TRUE) , mean_count_trees = mean(count_trees, na.rm = TRUE) , mean_count_trees_canopy = sum(count_trees_canopy, na.rm = TRUE) , mean_count_trees_subcanopy = sum(count_trees_subcanopy, na.rm = TRUE) , mean_hgt_m = mean(min_hgt_m, na.rm = TRUE) # , min_hgt_m = min(min_hgt_m, na.rm = TRUE) # , max_hgt_m = max(max_hgt_m, na.rm = TRUE) ) %&gt;% dplyr::arrange(desc(mean_count_trees)) , format = &quot;html&quot; , caption = &quot;Tree Crown Groups Summary Statistics&quot; , digits = 1 , col.names = c( &quot;Classification&quot; , &quot;# crown groups&quot; , &quot;area (m2)&quot; , &quot;TPH&quot; , &quot;# trees&quot; , &quot;# canopy trees&quot; , &quot;# subcanopy trees&quot; , &quot;height (m)&quot; # , &quot;min hgt (m)&quot; # , &quot;max hgt (m)&quot; ) , align=rep(&#39;c&#39;, 5) ) %&gt;% # kable_classic() %&gt;% add_header_above(c(&quot; &quot; = 2, &quot;Mean&quot; = 6)) %&gt;% kable_material(c(&quot;striped&quot;, &quot;hover&quot;)) %&gt;% # column_spec(., 2, width = &quot;20em&quot;) %&gt;% kable_styling(font_size = 11) Table 4.1: Tree Crown Groups Summary Statistics Mean Classification # crown groups area (m2) TPH # trees # canopy trees # subcanopy trees height (m) Continuous - Mixed 181 39848.9 365.9 1284.5 133442 99047 2.3 Continuous - Subcanopy 50 5169.3 462.2 209.7 1831 8653 2.2 Continuous - Canopy 100 4900.5 339.0 157.4 12999 2741 3.9 Medium Group - Subcanopy 149 360.9 583.5 18.5 321 2436 2.9 Medium Group - Mixed 342 458.2 435.5 18.2 3264 2958 3.5 Medium Group - Canopy 616 525.1 365.3 17.7 10163 767 8.0 Small Group - Mixed 4100 66.9 649.7 3.2 6846 6449 5.2 Small Group - Canopy 12597 84.0 463.5 3.2 38755 1008 12.5 Small Group - Subcanopy 3676 36.1 1290.0 2.9 417 10156 3.8 Individual Tree 63534 14.2 1908.8 1.0 34386 29148 9.3 4.7 Map Crowns and Rx Fire Area # make map # different background map types: https://leaflet-extras.github.io/leaflet-providers/preview/ # names(leaflet.providers::providers_loaded()$providers) mapviewOptions(homebutton = FALSE, basemaps = c(&quot;Esri.WorldImagery&quot;)) # crop data bhef_crowns_group &lt;- sf::st_intersection( crowns_group # dplyr::filter(crown_group_area_ha &lt;= 2) , rx_fire %&gt;% dplyr::select(unit) %&gt;% dplyr::slice_sample(prop = .5) ) %&gt;% sf::st_intersection(., bhef_boundary %&gt;% dplyr::select(name)) # bhef_crowns_group &lt;- sf::st_intersection( # crowns_group # # dplyr::filter(crown_group_area_ha &lt;= 2) # , sf::st_buffer(bhef_boundary %&gt;% dplyr::select(name), dist = -500) # ) # map mapview(bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) + mapview(rx_fire , color = &quot;orangered&quot; , lwd = 2 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) + mapview(bhef_crowns_group , zcol = &quot;crown_group_class&quot; , col.regions = viridis::turbo(n=length(unique(bhef_crowns_group$crown_group_class))) , lwd = 0 , alpha.regions = 0.8 , label = c(&quot;crown_group_class&quot;) , legend = FALSE , popup = popupTable( bhef_crowns_group , zcol = c( &quot;crown_group_class&quot; , &quot;count_trees&quot; , &quot;min_hgt_m&quot; , &quot;max_hgt_m&quot; , &quot;mean_hgt_m&quot; , &quot;count_trees_canopy&quot; , &quot;count_trees_subcanopy&quot; ) , row.numbers = FALSE , feature.id = FALSE ) ) Note: crown groups shown for only 50% of Rx Fire units (to enhance rendering performance). Crown group data for entire BHEF is still available. 4.8 Write Out Data if(overwrite_it == FALSE){ print(&quot;Proceeding to next section without processing or overwriting data...&quot;) }else{ # save cleaned data for reading to R later sf::st_write(crowns_group, &quot;../data/crowns_group.gpkg&quot;, append = FALSE) sf::st_write(tree_tops, &quot;../data/tree_tops.gpkg&quot;, append = FALSE) stars::write_stars(chm, &quot;../data/chm.tif&quot;, append = FALSE) } "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
