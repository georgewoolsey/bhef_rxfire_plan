[["index.html", "Black Hills Experimental Forest Prescribed Fire Planning Section 1 Introduction", " Black Hills Experimental Forest Prescribed Fire Planning George Woolsey 2023-06-02 Section 1 Introduction My name is George Woolsey and I am currently employed by the United States Forest Service working with Dr. Mike Battaglia at the Rocky Mountain Research Station in Fort Collins, Colorado. In addition, I am pursuing a MS in Forest Sciences at Colorado State University (CSU). At CSU I am working with Dr. Wade Tinkham in the Forest Biometrics Lab. "],["objective.html", "Section 2 Objective", " Section 2 Objective The objective of this analysis is to describe the site conditions on the Black Hills Experimental Forest (North Dakota, USA) for planning future prescribed fire treatments. This analysis incorporates the spatial location of research plots and some of the measurements collected at those plots (e.g. Ritter et al. 2022). In ponderosa pine (Pinus ponderosa) forests, prescribed fires and wildfires burning under moderate conditions can effectively reduce fuel loading and restore the structures and complex spatial patterns that existed in these forests historically (Holden et al. 2007; Battaglia et al. 2008). In the ponderosa pine forests of the Black Hills, ladder fuels can develop quickly after a mechanical treatment if regeneration densities are not regulated. Prescribed fire can successfully maintain low regeneration densities following fuel treatments (Battaglia et al. 2008). In addition to reducing tree densities and surface fuel loads, prescribed fires can be used to improve nutrient cycling, increase forage plant production, and improve wildlife habitat (DeBano et al. 1998; Allen et al. 2002). "],["vector_data.html", "Section 3 Import Vector Data 3.1 National Forest Management data download 3.2 Load Research Plot data 3.3 Load Stem Map data 3.4 Load Rx Fire shapefile 3.5 Load National Forests shapefile 3.6 Load Experimental Forests shapefile 3.7 Load FACTS Timber Stand Improvement 3.8 Load FACTS Timber Harvests 3.9 Join Research Plot to Harvest 3.10 Join Stem Map to Research Plot &amp; Harvest 3.11 Map Harvests, Research Plots, Stem Map 3.12 Write Out Data", " Section 3 Import Vector Data # turn off the s2 processing ## https://stackoverflow.com/questions/68478179/how-to-resolve-spherical-geometry-failures-when-joining-spatial-data sf::sf_use_s2(FALSE) 3.1 National Forest Management data download The Forest Activity Tracking System (FACTS) database maintained by the U.S. Department of Agriculture, Forest Service (USFS) used to delineate georeferenced boundaries of forest harvest activities. # check for data and download zip_path &lt;- c( &quot;https://data.fs.usda.gov/geodata/edw/edw_resources/fc/S_USA.NFSLandUnit.gdb.zip&quot; # forests boundaries , &quot;https://data.fs.usda.gov/geodata/edw/edw_resources/fc/S_USA.Experimental_Area_Boundaries.gdb.zip&quot; # exp forest boundaries # , &quot;https://data.fs.usda.gov/geodata/edw/edw_resources/fc/S_USA.Activity_TimberHarvest.gdb.zip&quot; # Timber Harvests # , &quot;https://data.fs.usda.gov/geodata/edw/edw_resources/shp/S_USA.Activity_HazFuelTrt_PL.zip&quot; # Hazardous Fuel Treatment Reduction # , &quot;https://data.fs.usda.gov/geodata/edw/edw_resources/shp/S_USA.Activity_SilvTSI.zip&quot; # SilvTSI (Silviculture Timber Stand Improvement) # , &quot;https://data.fs.usda.gov/geodata/edw/edw_resources/shp/S_USA.Activity_SilvReforestation.zip&quot; # SilvReforestation # , &quot;https://edcintl.cr.usgs.gov/downloads/sciweb1/shared/MTBS_Fire/data/composite_data/burned_area_extent_shapefile/mtbs_perimeter_data.zip&quot; ) for (i in 1:length(zip_path)) { f_nm &lt;- paste0( &quot;../data/&quot; , str_split(zip_path[i], &quot;/&quot;, simplify = TRUE)[length(str_split(zip_path[i], &quot;/&quot;, simplify = TRUE))] ) fldr &lt;- paste0(gsub(&quot;.zip&quot;, &quot;&quot;, f_nm)) options(timeout = 60 * 15) if(file.exists(fldr) == FALSE){ # download data if(file.exists(f_nm) == FALSE){ download.file(zip_path[i], destfile = f_nm) }else{print(&quot;file already exists&quot;)} # unzip unzip(f_nm, overwrite=TRUE, exdir = fldr) file.remove(f_nm) }else{print(&quot;unzip already exists&quot;)} } 3.2 Load Research Plot data Ritter et al. 2022 established eleven, 100x100 m (1-ha), plots within mechanical treatment units. Measurements occurred during the summer of 2017, which represented 3 years post-treatment for small group retention treatment and 4 years post-treatment for free selection-off, free selection-On, and commercial thinning treatments. In the free selection-off treatments, overstory trees were included in the spacing guidelines for precommercial thinning treatment. In the free selection-on treatments, overstory trees were not included in the spacing guidelines for precommercial thinning treatments resulting in residual precommercial trees potentially growing under the crown of an overstory tree. # load shapefile research_plots &lt;- sf::st_read(&quot;../data/Black_Hills_StemMaps.shp&quot;) %&gt;% dplyr::filter(sf::st_is_valid(.)) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) %&gt;% sf::st_buffer(dist = 50, endCapStyle = &quot;SQUARE&quot;) %&gt;% dplyr::mutate(area = sf::st_area(.)) #rename sf geom column names(research_plots)[names(research_plots)==tolower(attr(research_plots, &quot;sf_column&quot;))] = &quot;geometry&quot; sf::st_geometry(research_plots) = &quot;geometry&quot; # data structure of data research_plots %&gt;% glimpse() # plot does not uniquely identify record length(unique(research_plots$plot)) == nrow(research_plots) # create id research_plots &lt;- research_plots %&gt;% dplyr::group_by(plot) %&gt;% dplyr::mutate( plot_id = paste0(plot, &quot;_&quot;, as.character(dplyr::row_number())) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::relocate(plot_id) length(unique(research_plots$plot_id)) == nrow(research_plots) 3.3 Load Stem Map data Ritter et al. 2022 installed three plots in the commercial thin treatment and each of the two free selection treatments. Only two plots were installed in the small group retention treatment as it was smaller in area and was bisected by a powerline corridor that precluded the placement of more than two nonoverlapping plots. Each plot was subdivided into 16 25x25 m quadrats within which all live trees &gt;1.37 m tall had their x, y locations recorded. In addition to mapping their x, y location, all live trees were tagged and had their DBH, tree height (TH), compacted crown base height (CBH), crown width (CW), and species recorded. # load stem map shapefile stem_map &lt;- sf::st_read(&quot;../data/BHEF_stem_map.shp&quot;) %&gt;% dplyr::filter(sf::st_is_valid(.)) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) %&gt;% sf::st_transform(crs = sf::st_crs(research_plots)) ## Reading layer `BHEF_stem_map&#39; from data source ## `C:\\Data\\usfs\\bhef_rxfire_plan\\data\\BHEF_stem_map.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 1342 features and 19 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 607591.4 ymin: 4889665 xmax: 610681.1 ymax: 4893030 ## Projected CRS: WGS 84 / UTM zone 13N #rename sf geom column names(stem_map)[names(stem_map)==tolower(attr(stem_map, &quot;sf_column&quot;))] = &quot;geometry&quot; sf::st_geometry(stem_map) = &quot;geometry&quot; # data structure of stem map data stem_map %&gt;% glimpse() ## Rows: 1,342 ## Columns: 20 ## $ uidtree &lt;chr&gt; &quot;SQ_01_7_1272&quot;, &quot;SQ_01_7_1273&quot;, &quot;SQ_01_7_1274&quot;, &quot;SQ_01_7_12… ## $ utmx &lt;dbl&gt; 607759.6, 607766.1, 607767.7, 607773.3, 607774.8, 607767.4,… ## $ utmy &lt;dbl&gt; 4891801, 4891801, 4891805, 4891799, 4891800, 4891785, 48917… ## $ unit &lt;chr&gt; &quot;SQ_01&quot;, &quot;SQ_01&quot;, &quot;SQ_01&quot;, &quot;SQ_01&quot;, &quot;SQ_01&quot;, &quot;SQ_01&quot;, &quot;SQ_0… ## $ plot &lt;dbl&gt; 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,… ## $ tag &lt;dbl&gt; 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281,… ## $ status &lt;chr&gt; &quot;L&quot;, &quot;D&quot;, &quot;D&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;, &quot;D&quot;, &quot;D&quot;, &quot;L&quot;, &quot;L&quot;, &quot;L&quot;,… ## $ gst &lt;chr&gt; &quot;G&quot;, NA, NA, NA, NA, &quot;G&quot;, &quot;G&quot;, NA, NA, NA, NA, NA, NA, NA, … ## $ species &lt;chr&gt; &quot;PIPO&quot;, &quot;PIPO&quot;, &quot;PIPO&quot;, &quot;BEPA&quot;, &quot;BEPA&quot;, &quot;PIPO&quot;, &quot;PIPO&quot;, &quot;PI… ## $ count &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,… ## $ dbhin &lt;dbl&gt; 17.4, 8.7, 11.9, 8.1, 6.2, 14.9, 15.5, 13.6, 8.9, 11.5, 12.… ## $ dist &lt;dbl&gt; 57.6, 60.0, 74.1, 68.9, 74.6, 26.1, 29.1, 80.8, 65.8, 61.5,… ## $ azm &lt;dbl&gt; 0, 21, 21, 41, 42, 82, 146, 178, 200, 209, 211, 218, 234, 2… ## $ heightft &lt;dbl&gt; 69.8, 11.7, 14.3, 37.2, 18.9, 54.1, 63.4, 48.7, 14.4, 54.6,… ## $ cbhft &lt;dbl&gt; 26.4, 0.0, 0.0, 7.3, 6.4, 22.9, 23.7, 0.0, 0.0, 20.4, 21.9,… ## $ radialgrow &lt;dbl&gt; 12, 0, 0, 0, 0, 12, 15, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 24, … ## $ hgtgrowthf &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,… ## $ comments &lt;chr&gt; NA, &quot;BROKEN TOP&quot;, &quot;BROKEN TOP&quot;, &quot;DEAD TOP&quot;, &quot;BROKEN TOP&quot;, N… ## $ mpb &lt;chr&gt; &quot;no&quot;, &quot;no&quot;, &quot;no&quot;, &quot;no&quot;, &quot;no&quot;, &quot;no&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;yes&quot;, &quot;no… ## $ geometry &lt;POINT [m]&gt; POINT (607759.6 4891801), POINT (607766.1 4891801), P… 3.4 Load Rx Fire shapefile # load stem map shapefile rx_fire &lt;- sf::st_read(&quot;../data/ExpoRX.shp&quot;) %&gt;% dplyr::filter(sf::st_is_valid(.)) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) %&gt;% sf::st_transform(crs = sf::st_crs(research_plots)) ## Reading layer `ExpoRX&#39; from data source ## `C:\\Data\\usfs\\bhef_rxfire_plan\\data\\ExpoRX.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 20 features and 3 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 607447.8 ymin: 4888127 xmax: 610896.3 ymax: 4893405 ## Projected CRS: NAD83 / UTM zone 13N #rename sf geom column names(rx_fire)[names(rx_fire)==tolower(attr(rx_fire, &quot;sf_column&quot;))] = &quot;geometry&quot; sf::st_geometry(rx_fire) = &quot;geometry&quot; # data structure of stem map data rx_fire %&gt;% glimpse() ## Rows: 20 ## Columns: 4 ## $ id &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ## $ unit &lt;chr&gt; &quot;1&quot;, &quot;6&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;19&quot;, &quot;20&quot;, &quot;21&quot;, &quot;22… ## $ acres &lt;int&gt; 59, 134, 155, 90, 53, 116, 38, 494, 594, 194, 206, 89, 341, 1… ## $ geometry &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((609103.9 48..., MULTIPOLYGON (((608169.4 48..… 3.5 Load National Forests shapefile # load forest boundary shapefile # extract file name f_path &lt;- paste0(&quot;../data&quot;, &quot;/&quot;, &quot;S_USA.NFSLandUnit.gdb&quot;, &quot;/&quot;) dta_nm &lt;- paste(f_path , list.files(f_path, pattern = &quot;\\\\.gdb$&quot;)[1] , sep = &quot;/&quot; ) lyr_nms &lt;- sf::st_layers(dsn = dta_nm)$name lyr &lt;- lyr_nms[grep(&quot;NFSLandUnit&quot;, lyr_nms)][1] # load in data forests &lt;- sf::st_read( dsn = dta_nm , layer = lyr , query = &quot;SELECT * FROM \\&quot;NFSLandUnit\\&quot; WHERE REGION NOT IN (&#39;08&#39;, &#39;09&#39;, &#39;10&#39;) AND NFSLANDUNITTYPE = &#39;National Forest&#39; &quot; ) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) #rename sf geom column names(forests)[names(forests)==tolower(attr(forests, &quot;sf_column&quot;))] = &quot;geometry&quot; sf::st_geometry(forests) = &quot;geometry&quot; # transform forests &lt;- forests %&gt;% sf::st_transform(crs = sf::st_crs(research_plots)) #make BHNF only dataset forests_bhnf &lt;- forests %&gt;% filter(region == &quot;02&quot; &amp; nffid == &quot;0471&quot;) 3.6 Load Experimental Forests shapefile # load boundary shapefile # extract file name f_path &lt;- paste0(&quot;../data&quot;, &quot;/&quot;, &quot;S_USA.Experimental_Area_Boundaries.gdb&quot;, &quot;/&quot;) dta_nm &lt;- paste(f_path , list.files(f_path, pattern = &quot;\\\\.gdb$&quot;)[1] , sep = &quot;/&quot; ) lyr_nms &lt;- sf::st_layers(dsn = dta_nm)$name lyr &lt;- lyr_nms[grep(&quot;Experimental_Area_Boundaries&quot;, lyr_nms)][1] # load in data exp_forests &lt;- sf::st_read( dsn = dta_nm , layer = lyr ) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) #rename sf geom column names(exp_forests)[names(exp_forests)==tolower(attr(exp_forests, &quot;sf_column&quot;))] = &quot;geometry&quot; sf::st_geometry(exp_forests) = &quot;geometry&quot; # transform exp_forests &lt;- exp_forests %&gt;% sf::st_transform(crs = sf::st_crs(research_plots)) # spatial join BHNF bhef_boundary &lt;- sf::st_intersection(forests_bhnf %&gt;% dplyr::select(nfslandunitid, nffid, nfslandunitname), exp_forests) 3.7 Load FACTS Timber Stand Improvement The Silviculture Timber Stand Improvement metadata file is available here. Limited to activities in the Black Hills National Forest for preliminary analysis. This appendix includes a listing of all the active and inactive FACTS activity codes, as well as detailed descriptions of some of the codes. Utilize data downloaded and created in Forest Management Impacts on Productivity project. # load boundary shapefile tsi &lt;- sf::st_read(&quot;../data/tsi.gpkg&quot;) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) #rename sf geom column names(tsi)[names(tsi)==tolower(attr(tsi, &quot;sf_column&quot;))] = &quot;geometry&quot; sf::st_geometry(tsi) = &quot;geometry&quot; # transform tsi &lt;- tsi %&gt;% sf::st_transform(crs = sf::st_crs(research_plots)) # spatial join BHEF # bhef_tsi &lt;- sf::st_intersection( # bhef_boundary %&gt;% # dplyr::select(name, station, hectares, lead_scientist) %&gt;% # dplyr::rename_with(~ paste0(&quot;exp_forest_&quot;, .), -geometry) %&gt;% # # there are some plots outside of BHEF boundary # sf::st_buffer(2500) # , tsi) bhef_tsi &lt;- sf::st_intersection( # there are some plots outside of BHEF boundary sf::st_union( bhef_boundary , sf::st_as_sfc(sf::st_bbox(research_plots)) %&gt;% sf::st_transform(crs = sf::st_crs(research_plots)) ) %&gt;% dplyr::select(geometry) , tsi) 3.8 Load FACTS Timber Harvests Metadata file available here. Utilize data downloaded and created in Forest Management Impacts on Productivity project. This appendix includes a listing of all the active and inactive FACTS activity codes, as well as detailed descriptions of some of the codes. # load boundary shapefile harvests &lt;- sf::st_read(&quot;../data/harvests.gpkg&quot;) %&gt;% rename_with(~ tolower( gsub(&quot; &quot;, &quot;_&quot;, str_trim(gsub(&quot;\\\\s+&quot;, &quot; &quot;, .x)) ) )) #rename sf geom column names(harvests)[names(harvests)==tolower(attr(harvests, &quot;sf_column&quot;))] = &quot;geometry&quot; sf::st_geometry(harvests) = &quot;geometry&quot; # transform harvests &lt;- harvests %&gt;% sf::st_transform(crs = sf::st_crs(research_plots)) # spatial join BHEF # bhef_harvests &lt;- sf::st_intersection( # bhef_boundary %&gt;% # dplyr::select(name, station, hectares, lead_scientist) %&gt;% # dplyr::rename_with(~ paste0(&quot;exp_forest_&quot;, .), -geometry) %&gt;% # # there are some plots outside of BHEF boundary # sf::st_buffer(2500) # , harvests) bhef_harvests &lt;- sf::st_intersection( # there are some plots outside of BHEF boundary sf::st_union( bhef_boundary , sf::st_as_sfc(sf::st_bbox(research_plots)) %&gt;% sf::st_transform(crs = sf::st_crs(research_plots)) ) %&gt;% dplyr::select(geometry) , harvests) # filter for last 15 years bhef_harvests_l15 &lt;- bhef_harvests %&gt;% dplyr::filter(year_id &gt;= year(Sys.time()) - 15 ) %&gt;% dplyr::mutate(lab &lt;- paste0(treatment_type_grp, &quot; (&quot;, as.character(year_id), &quot;)&quot;)) 3.8.1 Harvests by treatment type # data by treatment type bhef_harvests_l15 %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(activity_name) %&gt;% dplyr::summarise(n = n()) %&gt;% dplyr::arrange(desc(n)) %&gt;% ggplot(.) + geom_col(aes(y = reorder(activity_name, n), x = n, fill = n), width = 0.7) + geom_text( aes(y = reorder(activity_name, n), x =n, label = scales::comma(n, accuracy = 1)) , color = &quot;black&quot;, size = 4 , position = position_dodge(0.9) , hjust = -0.1 ) + labs( title = &quot;Number Harvests Completed by Treatment Type (last 15 years)&quot; , subtitle = &quot;within BHEF boundary and bounding box of research plot area&quot; ) + xlab(&quot;# Harvests&quot;) + ylab(&quot;Treatment&quot;) + scale_x_continuous(labels = scales::comma) + scale_fill_viridis_c(alpha = 0.7, option = &quot;cividis&quot;, direction = -1) + theme_bw() + theme( legend.position = &quot;none&quot; ) 3.9 Join Research Plot to Harvest # attach harvest data to research plots research_plots_harvests &lt;- sf::st_intersection( research_plots , bhef_harvests_l15 %&gt;% dplyr::select( activity_code , activity_name , treatment_type_grp , suid , date_compl , year_id ) %&gt;% # dplyr::filter(treatment_type_grp %in% c(&quot;Commercial Thinning&quot; # , &quot;Overstory Removal Cut&quot; # , &quot;Single-tree/Group Selection Cut&quot; # , &quot;Patch Clearcut&quot; # )) %&gt;% dplyr::rename_with(~ paste0(&quot;harvest_&quot;, .), -geometry) ) %&gt;% dplyr::mutate(harvest_plot_areamsq = as.numeric(sf::st_area(.))) %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(plot_id) %&gt;% dplyr::arrange( plot_id , desc(harvest_plot_areamsq) , harvest_date_compl ) %&gt;% dplyr::select( plot_id , dplyr::starts_with(&quot;harvest_&quot;) ) %&gt;% dplyr::mutate( row_n = dplyr::row_number() ) %&gt;% dplyr::ungroup() %&gt;% tidyr::pivot_wider( id_cols = plot_id , names_from = row_n , values_from = !c(plot_id, row_n) , names_sep = &quot;_&quot; ) # join to spatial data research_plots &lt;- research_plots %&gt;% left_join(research_plots_harvests, by = c(&quot;plot_id&quot;=&quot;plot_id&quot;)) remove(research_plots_harvests) 3.10 Join Stem Map to Research Plot &amp; Harvest # attach harvest data to stem map stem_map_harvests &lt;- sf::st_intersection( stem_map , bhef_harvests_l15 %&gt;% dplyr::select( activity_code , activity_name , treatment_type_grp , suid , date_compl , year_id ) %&gt;% dplyr::rename_with(~ paste0(&quot;harvest_&quot;, .), -geometry) ) %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(uidtree) %&gt;% dplyr::arrange( uidtree , harvest_date_compl ) %&gt;% dplyr::select( uidtree , dplyr::starts_with(&quot;harvest_&quot;) ) %&gt;% dplyr::mutate( row_n = dplyr::row_number() ) %&gt;% dplyr::ungroup() %&gt;% tidyr::pivot_wider( id_cols = uidtree , names_from = row_n , values_from = !c(uidtree, row_n) , names_sep = &quot;_&quot; ) # join to spatial data stem_map &lt;- stem_map %&gt;% left_join(stem_map_harvests, by = c(&quot;uidtree&quot;=&quot;uidtree&quot;)) # join to research plot data temp_stem_map &lt;- sf::st_intersection( stem_map %&gt;% dplyr::select(uidtree) , research_plots %&gt;% dplyr::select(plot_id, trt, harvest_activity_name_1, harvest_year_id_1, harvest_treatment_type_grp_1) %&gt;% dplyr::rename_with(~ paste0(&quot;rplot_&quot;, .), -geometry) ) %&gt;% sf::st_set_geometry(NULL) stem_map &lt;- stem_map %&gt;% left_join(temp_stem_map, by = c(&quot;uidtree&quot;=&quot;uidtree&quot;)) remove(list = c(&quot;stem_map_harvests&quot;, &quot;temp_stem_map&quot;)) 3.10.1 Stem Map Descriptive statistics. # descriptive stats kable(stem_map %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by( unit , harvest_activity_name_1 ) %&gt;% dplyr::summarise( # plots = dplyr::n_distinct(plot) trees = dplyr::n_distinct(uidtree) , min_DBHin = min(dbhin) , max_DBHin = max(dbhin) , mean_DBHin = mean(dbhin) , QMDin = sqrt( sum(dbhin*dbhin) / n() ) , min_HTft = min(heightft) , max_HTft = max(heightft) , mean_HTft = mean(heightft) , stdev_HTft = sd(heightft) ) %&gt;% dplyr::arrange(unit, desc(trees)) , format = &quot;html&quot; , caption = &quot;Tree Measurement Descriptive Statistics by Unit &amp; Treatment&quot; , digits = 1 , col.names = c( &quot;unit&quot; , &quot;treatment&quot; # , &quot;# plots&quot; , &quot;# trees&quot; , &quot;min&quot; , &quot;max&quot; , &quot;mean&quot; , &quot;QMD&quot; , &quot;min&quot; , &quot;max&quot; , &quot;mean&quot; , &quot;st.dev.&quot; ) , align=rep(&#39;c&#39;, 5) ) %&gt;% add_header_above(c(&quot; &quot; = 3, &quot;DBH (in.)&quot; = 3, &quot;QMD (in.)&quot; = 1, &quot;Height (ft.)&quot; = 4)) %&gt;% kable_classic(full_width=T) %&gt;% kableExtra::kable_styling(font_size = 10,fixed_thead = TRUE) %&gt;% kableExtra::scroll_box(width = &quot;740px&quot;) Table 3.1: Tree Measurement Descriptive Statistics by Unit &amp; Treatment DBH (in.) QMD (in.) Height (ft.) unit treatment # trees min max mean QMD min max mean st.dev. SQ_01 Single-tree Selection Cut 63 3.1 18.6 10.7 11.7 10.1 72.6 42.6 22.5 SQ_01 Commercial Thin 11 4.6 15.4 12.0 12.3 29.8 66.5 56.8 10.2 SQ_02 Single-tree Selection Cut 215 0.4 19.2 7.3 8.1 4.8 67.9 33.6 15.4 SQ_02 NA 1 1.2 1.2 1.2 1.2 8.4 8.4 8.4 NA SQ_03 Single-tree Selection Cut 163 0.2 15.7 5.4 7.3 0.7 63.4 24.3 20.3 SQ_05 Single-tree Selection Cut 174 0.3 22.1 7.7 9.3 4.6 73.1 32.3 19.0 SQ_06 Single-tree Selection Cut 142 3.0 24.0 8.4 10.2 11.4 81.9 38.8 21.4 SQ_07 Single-tree Selection Cut 62 3.8 16.0 12.0 12.2 16.7 68.0 53.4 9.7 SQ_14 NA 251 0.1 15.3 5.7 7.5 4.5 66.7 29.5 21.0 SQ_14 Commercial Thin 1 8.2 8.2 8.2 8.2 41.1 41.1 41.1 NA SQ_20 Single-tree Selection Cut 150 0.3 23.4 5.4 7.8 4.8 80.2 26.3 23.6 SQ_23 Single-tree Selection Cut 109 0.2 19.9 8.3 9.6 4.6 64.8 34.0 16.8 3.11 Map Harvests, Research Plots, Stem Map # make map # different background map types: https://leaflet-extras.github.io/leaflet-providers/preview/ # names(leaflet.providers::providers_loaded()$providers) mapviewOptions(homebutton = FALSE, basemaps = c(&quot;Esri&quot;)) # map mapview(bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) + mapview(bhef_harvests_l15 , zcol = &quot;treatment_type_grp&quot; , col.regions = viridis::viridis(n=length(unique(bhef_harvests_l15$treatment_type_grp))) , alpha.regions = 0.6 , label = c(&quot;lab&quot;) , legend = FALSE , popup = popupTable( bhef_harvests_l15 , zcol = c( &quot;year_id&quot; , &quot;treatment_type_grp&quot; , &quot;activity_name&quot; ) , row.numbers = FALSE , feature.id = FALSE ) ) + mapview(rx_fire , color = &quot;red&quot; , lwd = 2 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) + mapview(research_plots , zcol = &quot;trt&quot; , col.regions = viridis::mako(n=length(unique(research_plots$trt)), direction = -1) , lwd = 2 , col = &quot;gray90&quot; , alpha.regions = 0.8 , label = c(&quot;trt&quot;) , legend = FALSE , popup = popupTable( research_plots , zcol = c( &quot;plot&quot; , &quot;trt&quot; , &quot;harvest_activity_name_1&quot; , &quot;harvest_year_id_1&quot; ) , row.numbers = FALSE , feature.id = FALSE ) ) + mapview(stem_map , zcol = &quot;unit&quot; , col.regions = viridis::turbo(n=length(unique(stem_map$unit)), alpha = 0.8) # RColorBrewer::brewer.pal(n = length(unique(stem_map$unit)), name = &quot;RdYlBu&quot;) , cex = 3.5 , label = c(&quot;unit&quot;) , legend = FALSE , popup = popupTable( stem_map , zcol = c( &quot;unit&quot; , &quot;plot&quot; , &quot;species&quot; , &quot;tag&quot; , &quot;heightft&quot; , &quot;dbhin&quot; , &quot;harvest_activity_name_1&quot; , &quot;harvest_year_id_1&quot; ) , row.numbers = FALSE , feature.id = FALSE ) ) Note, only harvests in last 15 years shown 3.12 Write Out Data # save cleaned data for reading to R later sf::st_write(forests_bhnf, &quot;../data/forests_bhnf.gpkg&quot;, append = FALSE) sf::st_write(bhef_boundary, &quot;../data/bhef_boundary.gpkg&quot;, append = FALSE) sf::st_write(bhef_tsi, &quot;../data/bhef_tsi.gpkg&quot;, append = FALSE) sf::st_write(bhef_harvests, &quot;../data/bhef_harvests.gpkg&quot;, append = FALSE) sf::st_write(research_plots, &quot;../data/research_plots.gpkg&quot;, append = FALSE) sf::st_write(stem_map, &quot;../data/stem_map.gpkg&quot;, append = FALSE) sf::st_write(rx_fire, &quot;../data/rx_fire.gpkg&quot;, append = FALSE) "],["lidar_data.html", "Section 4 Analyze Lidar Data 4.1 Overwrite Data Switch 4.2 Download Data From Nat’l Map 4.3 Load Vector Data 4.4 Load Elevation Data 4.5 Lidar Data Processing 4.6 Lidar-Derived Crown Groups Summary 4.7 Map Crowns and Rx Fire Area 4.8 Write Out Data", " Section 4 Analyze Lidar Data # turn off the s2 processing ## https://stackoverflow.com/questions/68478179/how-to-resolve-spherical-geometry-failures-when-joining-spatial-data sf::sf_use_s2(FALSE) 4.1 Overwrite Data Switch ####################################################### ####################################################### # TURN ON/OFF DATA OVERWRITE # TURNING THIS ON WILL RE-RUN ALL LIDAR PROCESSING # WHICH TAKES A LONG TIME ####################################################### ####################################################### overwrite_it &lt;- FALSE 4.2 Download Data From Nat’l Map The USGS National Map was used to obtain a list of file download links for “Elevation Source Data (3DEP) - Lidar, IfSAR” data available marked as “Lidar Point Cloud (LPC)”. This download file list was placed in the data folder where the code below utilizes it to download data. The “thumbnail” option in the Nat’l Map was used to determine that the “Fugro” data will suffice to cover the BHEF area. Also, downloaded NAIP imagery and 3dep elevation while had ROI drawn in Nat’l Map. ####################################################### ####################################################### # download lidar data ####################################################### ####################################################### # open download text file urls &lt;- read.delim(&quot;../data/usgs_lidar_data.txt&quot;, header = FALSE) %&gt;% dplyr::rename(url_path = 1) %&gt;% dplyr::filter(grepl(&quot;FUGRO&quot;, toupper(url_path)) == TRUE) %&gt;% dplyr::mutate( orig_fname = word(gsub(&quot;/&quot;, &quot; &quot;, url_path), -1) , fname_sans_typ = gsub(&quot;.laz&quot;, &quot;&quot;, orig_fname) ) # create parent directory for data hey_dir &lt;- &quot;../data/lidar/&quot; if(dir.exists(hey_dir)==FALSE){ dir.create(hey_dir) } #loop through to download lidar data for(i in 1:nrow(urls)){ # set up names f_nm &lt;- paste0(hey_dir , urls$orig_fname[i] ) options(timeout = 60 * 15) ######################## ## download and unzip ######################## if(file.exists(f_nm)==FALSE){ # download download.file(urls$url_path[i], destfile = f_nm) }else{ print(paste0(f_nm, &quot; file already exists&quot;)) } } ####################################################### ####################################################### # download elevation data ####################################################### ####################################################### # open download text file urls &lt;- read.delim(&quot;../data/usgs_dem_data.txt&quot;, header = FALSE) %&gt;% dplyr::rename(url_path = 1) %&gt;% dplyr::filter(grepl(&quot;FUGRO&quot;, toupper(url_path)) == TRUE) %&gt;% dplyr::mutate( orig_fname = word(gsub(&quot;/&quot;, &quot; &quot;, url_path), -1) , fname_sans_typ = gsub(&quot;.laz&quot;, &quot;&quot;, orig_fname) ) # create parent directory for data hey_dir &lt;- &quot;../data/dem/&quot; if(dir.exists(hey_dir)==FALSE){ dir.create(hey_dir) } #loop through to download dem data for(i in 1:nrow(urls)){ # set up names f_nm &lt;- paste0(hey_dir , urls$orig_fname[i] ) options(timeout = 60 * 15) ######################## ## download and unzip ######################## if(file.exists(f_nm)==FALSE){ # download download.file(urls$url_path[i], destfile = f_nm) }else{ print(paste0(f_nm, &quot; file already exists&quot;)) } } 4.3 Load Vector Data Spatial data was loaded and cleaned in prior chapter. # read forests_bhnf &lt;- sf::st_read(&quot;../data/forests_bhnf.gpkg&quot;) bhef_boundary &lt;- sf::st_read(&quot;../data/bhef_boundary.gpkg&quot;) bhef_harvests &lt;- sf::st_read(&quot;../data/bhef_harvests.gpkg&quot;) research_plots &lt;- sf::st_read(&quot;../data/research_plots.gpkg&quot;) stem_map &lt;- sf::st_read(&quot;../data/stem_map.gpkg&quot;) rx_fire &lt;- sf::st_read(&quot;../data/rx_fire.gpkg&quot;) # read files needed for visuals if not overwrite if(file.exists(&quot;../data/crowns_group.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ crowns_group &lt;- sf::st_read(&quot;../data/crowns_group.gpkg&quot;) } if(file.exists(&quot;../data/tree_tops.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ tree_tops &lt;- sf::st_read(&quot;../data/tree_tops.gpkg&quot;) } if(file.exists(&quot;../data/chm.tif&quot;) == TRUE &amp; overwrite_it == FALSE){ chm &lt;- stars::read_stars(&quot;../data/chm.tif&quot;) } 4.4 Load Elevation Data The USGS National Map was used to obtain a list of file download links for “Elevation Source Data (3DEP)” data. Using elevatr::get_elev_raster to get a digital elevation model (DEM) raster (~6.8m resolution) as a backup. ####################################################### ####################################################### # read elevation data ####################################################### ####################################################### if(file.exists(&quot;../data/bhef_elev.tif&quot;) == FALSE){ ####################################################### # 1 m dem ####################################################### # tifs &lt;- list.files(&quot;../data/dem/&quot;, pattern = &quot;\\\\.tif$&quot;, full.names = TRUE) # # newgrid &lt;- bhef_boundary %&gt;% # sf::st_buffer(dist = 10000) %&gt;% # sf::st_bbox() %&gt;% # stars::st_as_stars(dx = 1, dy = 1) # # stars::st_as_stars() # # # read files # for(i in 1:length(tifs)){ # f_nm &lt;- paste0(&quot;elev_&quot;, i) # assign(f_nm, # stars::read_stars(tifs[i]) %&gt;% # stars::st_warp(newgrid) %&gt;% # setNames(&quot;elev&quot;) # # sf::st_transform(crs = sf::st_crs(bhef_boundary)) # ) # } # # mosaic together !!!!!!!!!!!!!!! NEED TO REMOVE HARD-CODING OF OBJECT NAMES # elev &lt;- stars::st_mosaic(elev_1, elev_2, elev_3, elev_4) # remove(list = ls(pattern = &quot;elev_&quot;) ) # bhef_elev &lt;- elev[sf::st_buffer(bhef_boundary, dist = 1000)] ####################################################### # not 1 m dem ####################################################### # z =14 is highest resolution (~6.8m) elev &lt;- elevatr::get_elev_raster(bhef_boundary, z = 14) # sf::st_crs(elev) == sf::st_crs(bhef_boundary) bhef_elev &lt;- stars::st_as_stars(elev) # sf::st_transform(crs = sf::st_crs(bhef_boundary)) # save stars::write_stars(bhef_elev, &quot;../data/bhef_elev.tif&quot;, append = FALSE) }else{ bhef_elev &lt;- stars::read_stars(&quot;../data/bhef_elev.tif&quot;) } 4.4.1 Elevation plot # plot ggplot() + geom_raster( data = bhef_elev %&gt;% terra::rast() %&gt;% terra::mask( bhef_boundary %&gt;% terra::vect() ) %&gt;% as.data.frame(xy=T) %&gt;% dplyr::rename(elev = 3) , mapping = aes(x=x,y=y,fill=elev) ) + # stars::geom_stars(data = bhef_elev[bhef_boundary]) + geom_sf(data = bhef_boundary, alpha = 0, lwd = 1, color = &quot;black&quot;, linetype = &quot;dashed&quot;) + scale_fill_viridis_c( option = &quot;viridis&quot; , alpha = 0.9 , na.value = &quot;transparent&quot; , breaks = scales::extended_breaks(n = 6) , labels = scales::comma ) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( title = &quot;BHEF Elevation Map&quot; , subtitle = sf::st_crs(bhef_elev)$input , x = &quot;&quot; , y = &quot;&quot; , fill = &quot;Elev. (m)&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.box.margin = margin(-7,0,2,0) , legend.text = element_text(size = 7, angle = 25, hjust = 0.7) , legend.title = element_text(size = 7) , axis.text = element_text(size = 7) , panel.border = element_blank() ) 4.5 Lidar Data Processing Use the lidR package for manipulating and visualizing point cloud data. See the very helpful book by Roussel, J.R., Goodbody, T.R.H., and Tompalski P. (2021) for more information. if(file.exists(&quot;../data/crowns_group.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ print(&quot;Proceeding to next section without processing or overwriting data...&quot;) }else{ ###################################################### # transform laz files ###################################################### # create directory for transformed data old_dir &lt;- &quot;../data/lidar/&quot; new_dir &lt;- &quot;../data/lidar/transform/&quot; if(dir.exists(new_dir)==FALSE){ dir.create(new_dir) } # determine non transformed files lazs_trans &lt;- sort(list.files(new_dir, pattern = &quot;\\\\.laz$&quot;, full.names = FALSE)) lazs_orig &lt;- sort(list.files(old_dir, pattern = &quot;\\\\.laz$&quot;, full.names = FALSE)) non_trans &lt;- lazs_orig[!lazs_orig %in% lazs_trans] # loop to transform and write if(length(non_trans) &gt; 0){ for (i in 1:length(non_trans)) { # read temp_laz &lt;- lidR::readLAS( paste0(old_dir, non_trans[i]) , select = &quot;xyz&quot; ) %&gt;% sf::st_transform(crs = sf::st_crs(bhef_elev)) # write lidR::writeLAS( temp_laz , paste0(new_dir, non_trans[i]) ) remove(temp_laz) } } remove(temp_laz, lazs_trans, lazs_orig, non_trans) gc() ###################################################### # read laz files ###################################################### # list laz files lazs &lt;- sort(list.files(new_dir, pattern = &quot;\\\\.laz$&quot;, full.names = TRUE), decreasing = FALSE) # change projection of DEM # # creating a new regular grid in a new CRS # newgrid &lt;- bhef_boundary %&gt;% # sf::st_transform(crs = sf::st_crs( lidR::readLAS(lazs[1], select = &quot;xyz&quot;) )) %&gt;% # sf::st_bbox() %&gt;% # stars::st_as_stars() # # set up old grid to warp back # oldgrid &lt;- bhef_boundary %&gt;% # sf::st_bbox() %&gt;% # stars::st_as_stars() # # warping the old raster to the new grid # bhef_elev_reproj &lt;- bhef_elev %&gt;% # stars::st_warp(newgrid) # bhef_elev_reproj &lt;- bhef_elev %&gt;% stars::st_warp(crs = sf::st_crs( lidR::readLAS(lazs[1], select = &quot;xyz&quot;) )) # If several files are read at once the returned LAS object is considered as one LAS file. # las &lt;- lidR::readLAS(lazs[2], select = &quot;xyz&quot;) %&gt;% # load XYZ only las &lt;- lidR::readLAS(lazs, select = &quot;xyz&quot;) # sf::st_transform(crs = sf::st_crs(bhef_elev)) # lidR::las_check(las) # remove duplicate points las &lt;- lidR::filter_duplicates(las) # lidR::las_check(las) # summary(las$Z) # sf::st_crs(las) # temp_plot &lt;- plot(las, color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;) # temp_plot # # add_treetops3d(temp_plot, tree_tops) ###################################################### # remove outliers ###################################################### # Use Statistical Outliers Removal (SOR) # k = number of neighbors # m = multiplier in : avg distance + m * std deviation las &lt;- lidR::classify_noise(las, sor(k = 15, m = 7)) # plot(las, color = &quot;Classification&quot;, bg = &quot;white&quot;, size = 3) # Remove outliers using filter_poi() las &lt;- lidR::filter_poi(las, Classification != LASNOISE) # plot(las, color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;) # #repeat process with Isolated Voxels Filter IVF # las &lt;- lidR::classify_noise(las, ivf(res = 5, n = 6)) # # plot(las, color = &quot;Classification&quot;, bg = &quot;white&quot;, size = 3) # # Remove outliers using lidR::filter_poi() # las &lt;- lidR::filter_poi(las, Classification != LASNOISE) # plot(las, color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;) # ##################################################### # Ground classification # !!!!!!!!!!!!!!!!!!!!!!!!!! This is computationally intensive :&#39;( # ##################################################### # ################################################## # Progressive Morphological Filter The implementation of PMF algorithm in lidR # is based on the method described in Zhang et al. (2003) # ################################################## # # # b numeric. This is the parameter b in Zhang et al. (2003) (eq. 4 and 5). # # # dh0 numeric. This is dh0 in Zhang et al. (2003) (eq. 7). # # # dhmax numeric. This is dhmax in Zhang et al. (2003) (eq. 7). # # # s numeric. This is s in Zhang et al. (2003) (eq. 7). # # # max_ws numeric. Maximum window size to be used in filtering ground returns. This # # # limits the number of windows created. # # # exp logical. The window size can be increased linearly or exponentially (eq. 4 or 5). # # lidR::util_makeZhangParam( # # b = 2, # # dh0 = 0.2, # # dhmax = 210, # # s = 1.2, # # max_ws = 20, # # exp = FALSE # # ) # las &lt;- lidR::classify_ground(las, algorithm = pmf( # ws = lidR::util_makeZhangParam()$ws # , th = lidR::util_makeZhangParam()$th # ) # ) } 4.5.1 Height normalization using DEM Height normalization using the DEM loaded above subtacts the height of the ground surface from the point cloud at the resolution of the DEM raster data. The resulting normalized point cloud data classifies ground points at 0 meter in height (Z) and all points &gt;0 meters in height is assumed to be non-ground surface cover. if(file.exists(&quot;../data/crowns_group.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ print(&quot;Proceeding to next section without processing or overwriting data...&quot;) }else{ ###################################################### # Height normalization using DEM # could create own DEM with lidar data ... # but will use out of the box product for now ###################################################### # subtract DEM from lidar returns nlas &lt;- las - bhef_elev # correct for below ground returns nlas@data$Z &lt;- ifelse( ceiling(nlas@data$Z) == 0 | floor(nlas@data$Z) == 0 | nlas@data$Z &lt;= 0 , 0, nlas@data$Z ) # nlas &lt;- filter_poi(nlas, Z &gt;= 0) # remove below ground points nlas@data$Z &lt;- ifelse(nlas@data$Z &lt;= 0, 0, nlas@data$Z) # update classification nlas@data$Classification &lt;- ifelse(nlas@data$Z==0, 2, nlas@data$Classification) # filter out top 0.2% heights nlas &lt;- filter_poi(nlas, Z &lt;= stats::quantile((nlas@data %&gt;% dplyr::filter(Classification==1))$Z, 0.998)) # plot(nlas, color = &quot;Z&quot;, breaks = &quot;pretty&quot;, bg = &quot;white&quot;) # summary(nlas$Z) # table(nlas$Classification) # ###################################################### # # Height normalization using point cloud interpolation # # !!!!!! must run ground classification above first # ###################################################### # # point cloud normalization using interpolation # nlas &lt;- normalize_height(las, knnidw()) # # plot(nlas, color = &quot;Z&quot;, breaks = &quot;pretty&quot;, bg = &quot;white&quot;) # # plot(lidR::filter_ground(nlas), color = &quot;Classification&quot;, bg = &quot;white&quot;) # # summary(nlas$Z) # # table(nlas$Classification) ###################################################### # descriptive stats ###################################################### kable(nlas@data %&gt;% dplyr::group_by( Classification ) %&gt;% dplyr::summarise( # plots = dplyr::n_distinct(plot) points = dplyr::n() , min_z = min(Z) , max_z = max(Z) , mean_z = mean(Z) , median_z = median(Z) , stdev_z = sd(Z) ) %&gt;% dplyr::arrange(Classification) %&gt;% dplyr::mutate( Classification = dplyr::case_when( Classification == 1 ~ &quot;Surface&quot; , Classification == 2 ~ &quot;Ground&quot; , TRUE ~ &quot;Other&quot; ) ) , format = &quot;html&quot; , caption = &quot;Point Cloud Summary Statistics for Return Height (Z)&quot; , digits = 1 , col.names = c( &quot;Classification&quot; , &quot;points&quot; , &quot;min&quot; , &quot;max&quot; , &quot;mean&quot; , &quot;median&quot; , &quot;st.dev.&quot; ) , align=rep(&#39;c&#39;, 5) ) %&gt;% # kable_classic() %&gt;% add_header_above(c(&quot; &quot; = 2, &quot;Point Return Height (m)&quot; = 5)) %&gt;% kable_classic(full_width=T) %&gt;% kableExtra::kable_styling(font_size = 10,fixed_thead = TRUE) %&gt;% kableExtra::scroll_box(width = &quot;740px&quot;) # ggplot() + geom_histogram(data = (nlas@data %&gt;% dplyr::filter(Classification == 1)), aes(Z), binwidth = 1) } 4.5.2 Canopy Height model Points-to-raster algorithm with a resolution of 1 meter. For each pixel of the output raster the function attributes the height of the highest point found in the pixel from the point cloud. if(file.exists(&quot;../data/crowns_group.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ print(&quot;Proceeding to next section without processing or overwriting data...&quot;) }else{ ###################################################### # Canopy Height model ###################################################### # Points-to-raster algorithm with a resolution of 1 meter chm &lt;- lidR::rasterize_canopy( nlas , res = 1 # for each pixel of the output raster the function attributes the height of the highest point found , p2r(subcircle = 0.0 # , na.fill = tin() , na.fill = knnidw( k = 10 , p = 2 , rmax = 5 ) ) , pkg = &quot;terra&quot; ) # smooth chm pixels with median value in 3x3 matrix kernel &lt;- matrix(1,3,3) chm_smooth &lt;- terra::focal(chm, w = kernel, fun = median, na.rm = TRUE) %&gt;% stars::st_as_stars() # stars::st_warp(crs = sf::st_crs(bhef_boundary)) # %&gt;% # sf::st_transform(crs = sf::st_crs(bhef_boundary)) # non smoothed chm &lt;- chm %&gt;% stars::st_as_stars() # stars::st_warp(crs = sf::st_crs(bhef_boundary)) } 4.5.2.1 CHM plot # plot ggplot() + stars::geom_stars(data = chm[rx_fire %&gt;% dplyr::slice_head(n = 1)]) + # geom_sf(data = sf::st_crop(bhef_boundary, sf::st_bbox(chm_smooth)), alpha = 0, lwd = 0) + geom_sf(data = rx_fire %&gt;% dplyr::slice_head(n = 1), alpha = 0, lwd = 1, color = &quot;orangered&quot;) + scale_fill_viridis_c(option = &quot;mako&quot;, alpha = 0.9, na.value = &quot;transparent&quot;) + labs( title = &quot;BHEF Canopy Height Model&quot; , subtitle = paste0(&quot;sample Rx fire unit (&quot;, sf::st_crs(chm)$input, &quot;)&quot;) ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme( # legend.position = &quot;bottom&quot; # , legend.direction = &quot;horizontal&quot; axis.text = element_text(size = 8) # , panel.grid = element_blank() , panel.border = element_blank() ) + guides( fill = guide_legend(title=&quot;Hgt. (m)&quot;) ) 4.5.3 Individual Tree Detection (ITD) Local maximum filtering (LMF) with variable window size. Points below 2 m will equate to a window size of 3 m, while points above 20 meters equate to a window size of 5 m. Anything between 2 and 20 meter will have a non-linear relationship. if(file.exists(&quot;../data/crowns_group.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ print(&quot;Proceeding to next section without processing or overwriting data...&quot;) }else{ ###################################################### # Individual Tree Detection (ITD) ###################################################### # local maximum filtering (LMF) with variable window size # points below 2 m will equate to a window size of 3 m, # while points above 20 meters equate to a window size of 5 m. # Anything between 2 and 20 meter will have a non-linear relationship # define variable window function ws_fn &lt;- function(x) { y &lt;- 2.6 * (-(exp(-0.08*(x-2)) - 1)) + 3 y[x &lt; 2] &lt;- 3 y[x &gt; 20] &lt;- 5 return(y) } # ITD on CHM tree_tops &lt;- lidR::locate_trees(chm_smooth, lmf(ws = ws_fn)) %&gt;% # create classes based on Steel et al. 2021 dplyr::mutate( tree_class = dplyr::case_when( Z &gt; 8 ~ 3 # canopy , Z &gt;= 2 ~ 2 # subcanopy , Z &gt;= 1 ~ 1 # understory , TRUE ~ 0 # ground ) ) } 4.5.3.1 Tree Tops plot # plot ggplot() + stars::geom_stars(data = chm[rx_fire %&gt;% dplyr::slice_head(n = 1)]) + geom_sf(data = rx_fire %&gt;% dplyr::slice_head(n = 1), alpha = 0, lwd = 1, color = &quot;orangered&quot;) + geom_sf(data = sf::st_intersection(tree_tops, rx_fire %&gt;% dplyr::slice_head(n = 1)) , color = viridis::viridis(n=1, direction = -1), alpha = 0.7, shape = &quot;.&quot; ) + scale_fill_viridis_c(option = &quot;mako&quot;, alpha = 0.9, na.value = &quot;transparent&quot;) + labs( title = &quot;BHEF Canopy Height Model with Tree Tops Identified (yellow)&quot; , subtitle = paste0(&quot;sample Rx fire unit (&quot;, sf::st_crs(chm)$input, &quot;)&quot;) ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme_bw() + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme( axis.text = element_text(size = 8) # , panel.grid = element_blank() , panel.border = element_blank() ) + guides( fill = guide_legend(title=&quot;Hgt. (m)&quot;) ) # hey_plot &lt;- plot(nlas, color = &quot;Z&quot;, breaks = &quot;pretty&quot;, bg = &quot;white&quot;) # add_treetops3d(hey_plot, tree_tops &lt;- lidR::locate_trees(chm_smooth, lmf(ws = ws_fn)), col = &quot;black&quot;) # ?lidR::pixel_metrics() 4.5.3.2 Distribution of Tree Top Heights ###################################################### # height range of tree tops ###################################################### tree_tops %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::mutate(height_ceil = ceiling(Z)) %&gt;% dplyr::group_by(height_ceil) %&gt;% dplyr::summarise(n = n()) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( pct_tot = n / sum(n) ) %&gt;% ggplot(.) + # geom_col(aes(x = height_ceil, y = n, fill = n)) + geom_bar(aes(x = height_ceil, y = pct_tot, fill = n), color = &quot;gray25&quot;, stat = &quot;identity&quot;) + scale_y_continuous(labels = scales::label_percent(accuracy = 1L)) + scale_x_continuous(breaks = seq(min(tree_tops$Z), max(tree_tops$Z)+1, 1))+ scale_fill_viridis_c(alpha = 0.9, option = &quot;mako&quot;, direction = -1) + labs( title = &quot;Distribution of Tree Top Heights (m)&quot; ) + xlab(&quot;Tree Height (m) Bin&quot;) + ylab(&quot;% Tree tops&quot;) + theme_bw() + theme( legend.position=&quot;none&quot; ) 4.5.4 Individual Tree Crown (ITC) Segmentation Segment the canopy height model raster grid as individual tree crowns (ITC). Following the seeds + growing region algorithm described by Dalponte and Coomes (2016) to create a vector representation of tree crowns. Then using the individual tree crowns to create groupings and summary statistics of height for each interconnected crown group. if(file.exists(&quot;../data/crowns_group.gpkg&quot;) == TRUE &amp; overwrite_it == FALSE){ print(&quot;Proceeding to next section without processing or overwriting data...&quot;) }else{ ###################################################### # Individual Tree Segmentation (ITS) ###################################################### # implements an algorithm for tree segmentation based on # Dalponte and Coomes (2016) algorithm (see reference). # This is a seeds + growing region algorithm. algo &lt;- lidR::dalponte2016( chm = chm , treetops = tree_tops # Threshold below which a pixel cannot be a tree , th_tree = 2 # Pixel is added to a region if its height is greater than the tree height multiplied by this value. , th_seed = 0.45 # Pixel is added to a region if its height is greater than the current # mean height of the region multiplied by this value. , th_cr = 0.55 # Maximum value of the crown diameter of a detected tree (in pixels) , max_cr = 10 # If treetops contains an attribute with the ID for each tree, the name of this attribute , ID = &quot;treeID&quot; ) crowns_st &lt;- algo() # quick plot # plot(crowns_st, col = lidR::pastel.colors(200), main = &quot;Individual Tree Crowns&quot;) # transform crowns stars object to vector data crowns_sf &lt;- crowns_st %&gt;% # convert to vector data and merge polygons with identical pixel values sf::st_as_sf(as_points = FALSE, merge = TRUE) %&gt;% # transform to same crs as rest of data # transformed las data above instead # sf::st_transform(crs = st_crs(bhef_boundary)) %&gt;% dplyr::mutate( tree_id = values , crown_area = sf::st_area(.) ) %&gt;% dplyr::relocate(tree_id, crown_area) %&gt;% dplyr::select(tree_id, crown_area) %&gt;% sf::st_set_precision(1e7) %&gt;% sf::st_make_valid(.) %&gt;% dplyr::filter(sf::st_is_valid(.)) # combine crown groups crowns_group &lt;- sf::st_cast( sf::st_union(crowns_sf) , &quot;POLYGON&quot;) # quick plot # plot(crowns_group, col = lidR::pastel.colors(200), main = &quot;Tree Crown Groups&quot;) #create id column crowns_group &lt;- crowns_group %&gt;% merge(., data.frame(geo_type = sf::st_geometry_type(crowns_group)), by.x=0, by.y=0, all.x=TRUE) %&gt;% dplyr::mutate(crown_group_id = as.numeric(as.factor(Row.names))) %&gt;% dplyr::select(-c(geo_type, Row.names)) %&gt;% dplyr::relocate(crown_group_id) %&gt;% sf::st_as_sf(., sf_column_name = &quot;geometry&quot;, crs = sf::st_crs(bhef_boundary)) # join back to individual tree crowns and summarize crowns_group_sum &lt;- sf::st_intersection(tree_tops, crowns_group) %&gt;% # if need to keep group at tree level... break here sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(crown_group_id) %&gt;% dplyr::summarise( count_trees = dplyr::n_distinct(treeID) , min_hgt_m = min(Z, na.rm = TRUE) , max_hgt_m = max(Z, na.rm = TRUE) , mean_hgt_m = mean(Z, na.rm = TRUE) , median_hgt_m = median(Z, na.rm = TRUE) , median_hgt_m = median(Z, na.rm = TRUE) , quant10_hgt_m = as.numeric( quantile(Z, probs = .10, na.rm = TRUE) ) , quant25_hgt_m = as.numeric( quantile(Z, probs = .25, na.rm = TRUE) ) , quant50_hgt_m = as.numeric( quantile(Z, probs = .50, na.rm = TRUE) ) , quant75_hgt_m = as.numeric( quantile(Z, probs = .75, na.rm = TRUE) ) , quant90_hgt_m = as.numeric( quantile(Z, probs = .90, na.rm = TRUE) ) , count_trees_canopy = sum(ifelse(tree_class == 3, 1, 0), na.rm = TRUE) , count_trees_subcanopy = sum(ifelse(tree_class == 2, 1, 0), na.rm = TRUE) , count_trees_understory = sum(ifelse(tree_class == 1, 1, 0), na.rm = TRUE) , count_trees_ground = sum(ifelse(tree_class == 0, 1, 0), na.rm = TRUE) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::arrange(crown_group_id) %&gt;% dplyr::mutate( crown_group_class = dplyr::case_when( count_trees == 1 ~ &quot;Individual Tree&quot; , count_trees &lt;= 10 &amp; count_trees_canopy/count_trees &gt;= .75 ~ &quot;Small Group - Canopy&quot; , count_trees &lt;= 10 &amp; count_trees_subcanopy/count_trees &gt;= .75 ~ &quot;Small Group - Subcanopy&quot; , count_trees &lt;= 10 ~ &quot;Small Group - Mixed&quot; , count_trees &lt;= 40 &amp; count_trees_canopy/count_trees &gt;= .75 ~ &quot;Medium Group - Canopy&quot; , count_trees &lt;= 40 &amp; count_trees_subcanopy/count_trees &gt;= .75 ~ &quot;Medium Group - Subcanopy&quot; , count_trees &lt;= 40 ~ &quot;Medium Group - Mixed&quot; , count_trees_canopy/count_trees &gt;= .75 ~ &quot;Continuous - Canopy&quot; , count_trees_subcanopy/count_trees &gt;= .75 ~ &quot;Continuous - Subcanopy&quot; , TRUE ~ &quot;Continuous - Mixed&quot; ) ) #attach summary statistics to spatial crown groups crowns_group &lt;- crowns_group %&gt;% dplyr::left_join(crowns_group_sum, by = c(&quot;crown_group_id&quot; = &quot;crown_group_id&quot;)) %&gt;% dplyr::mutate( crown_group_area_ha = as.numeric(sf::st_area(.)) / 10000 , trees_per_ha = count_trees / crown_group_area_ha ) } 4.6 Lidar-Derived Crown Groups Summary Tree classes are based on Steel et al. 2021. Height thresholds were used to define canopy (&gt;8 m), subcanopy (2–8 m) and understory (1–2 m). Crown groups are defined by the number of trees in a crown group and the composition of canopy and subcanopy trees in the group: Individual Tree : Single tree &gt;= 2m tall in 2017 (canopy or subcanopy) without interlocking crown Small Group - Canopy : 2-10 trees with interlocking crowns where 75% or more of the trees are canopy (&gt;8 m) Small Group - Subcanopy : 2-10 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m) Small Group - Mixed : 2-10 trees with interlocking crowns with neither canopy nor subcanopy comprising &gt;75% of trees Medium Group - Canopy : 11-40 trees with interlocking crowns where 75% or more of the trees are canopy (&gt;8 m) Medium Group - Subcanopy : 11-40 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m) Medium Group - Mixed : 11-40 trees with interlocking crowns with neither canopy nor subcanopy comprising &gt;75% of trees Continuous - Canopy : &gt;40 trees with interlocking crowns where 75% or more of the trees are canopy (&gt;8 m) Continuous - Subcanopy : &gt;40 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m) Continuous - Mixed : &gt;40 trees with interlocking crowns with neither canopy nor subcanopy comprising &gt;75% of trees # plot ggplot() + geom_sf(data = sf::st_intersection(crowns_group, rx_fire %&gt;% dplyr::slice_head(n = 1)) , aes(fill = crown_group_class) , lwd = 0 ) + geom_sf(data = rx_fire %&gt;% dplyr::slice_head(n = 1), alpha = 0, lwd = 1, color = &quot;orangered&quot;) + scale_fill_viridis_d(option = &quot;turbo&quot;, alpha = 0.9) + labs( title = &quot;BHEF Crown Groups Classes&quot; , subtitle = paste0(&quot;sample Rx fire unit (&quot;, sf::st_crs(crowns_group)$input, &quot;)&quot;) ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme( legend.position = &quot;bottom&quot; , legend.title = element_blank() , axis.text = element_text(size = 8) # , panel.grid = element_blank() , panel.border = element_blank() ) 4.6.1 Crown Group Summary Statistics # table kable(crowns_group %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by( crown_group_class ) %&gt;% dplyr::summarise( # plots = dplyr::n_distinct(plot) crown_groups = dplyr::n() , mean_m2 = mean(crown_group_area_ha, na.rm = TRUE) * 10000 , trees_per_ha = mean(trees_per_ha, na.rm = TRUE) , mean_count_trees = mean(count_trees, na.rm = TRUE) , mean_count_trees_canopy = mean(count_trees_canopy, na.rm = TRUE) , mean_count_trees_subcanopy = mean(count_trees_subcanopy, na.rm = TRUE) , mean_hgt_m = mean(mean_hgt_m, na.rm = TRUE) # , min_hgt_m = min(min_hgt_m, na.rm = TRUE) # , max_hgt_m = max(max_hgt_m, na.rm = TRUE) ) %&gt;% dplyr::arrange(desc(mean_count_trees)) , format = &quot;html&quot; , caption = &quot;Tree Crown Groups Summary Statistics&quot; , digits = 1 , col.names = c( &quot;Classification&quot; , &quot;# crown groups&quot; , &quot;area (m2)&quot; , &quot;TPH&quot; , &quot;# trees&quot; , &quot;# canopy trees&quot; , &quot;# subcanopy trees&quot; , &quot;height (m)&quot; # , &quot;min hgt (m)&quot; # , &quot;max hgt (m)&quot; ) , align=rep(&#39;c&#39;, 5) ) %&gt;% add_header_above(c(&quot; &quot; = 2, &quot;Mean&quot; = 6)) %&gt;% kable_classic(full_width=T) %&gt;% kableExtra::kable_styling(font_size = 10,fixed_thead = TRUE) %&gt;% kableExtra::scroll_box(width = &quot;740px&quot;) Table 4.1: Tree Crown Groups Summary Statistics Mean Classification # crown groups area (m2) TPH # trees # canopy trees # subcanopy trees height (m) Continuous - Mixed 205 11630.4 370.6 400.0 235.4 164.7 9.8 Continuous - Canopy 238 5923.6 345.9 194.7 167.7 27.0 13.1 Continuous - Subcanopy 51 3649.0 461.6 159.9 19.6 140.3 5.3 Medium Group - Mixed 665 504.9 406.1 18.9 10.0 8.9 9.9 Medium Group - Canopy 1149 523.1 367.7 17.9 16.6 1.3 13.8 Medium Group - Subcanopy 250 352.2 544.3 17.3 2.2 15.2 5.4 Small Group - Mixed 6205 71.1 633.4 3.3 1.7 1.6 9.5 Small Group - Canopy 18710 84.3 473.2 3.2 3.1 0.1 14.4 Small Group - Subcanopy 5026 39.8 1211.2 3.0 0.1 2.9 4.6 Individual Tree 85680 14.3 1848.5 1.0 0.6 0.4 9.4 # column_spec(1, bold = TRUE, width = &quot;5em&quot;) 4.7 Map Crowns and Rx Fire Area # make map # different background map types: https://leaflet-extras.github.io/leaflet-providers/preview/ # names(leaflet.providers::providers_loaded()$providers) mapviewOptions(homebutton = FALSE, basemaps = c(&quot;Esri.WorldImagery&quot;)) # crop data bhef_crowns_group &lt;- sf::st_intersection( crowns_group # dplyr::filter(crown_group_area_ha &lt;= 2) , rx_fire %&gt;% dplyr::select(unit) %&gt;% dplyr::slice_sample(prop = .5) ) %&gt;% sf::st_intersection(., bhef_boundary %&gt;% dplyr::select(name)) # bhef_crowns_group &lt;- sf::st_intersection( # crowns_group # # dplyr::filter(crown_group_area_ha &lt;= 2) # , sf::st_buffer(bhef_boundary %&gt;% dplyr::select(name), dist = -500) # ) # map mapview(bhef_boundary , color = &quot;black&quot; , lwd = 3 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) + mapview(rx_fire , color = &quot;orangered&quot; , lwd = 2 , alpha.regions = 0 , label = FALSE , legend = FALSE , popup = FALSE ) + mapview(bhef_crowns_group , zcol = &quot;crown_group_class&quot; , col.regions = viridis::turbo(n=length(unique(bhef_crowns_group$crown_group_class))) , lwd = 0 , alpha.regions = 0.8 , label = c(&quot;crown_group_class&quot;) , legend = FALSE , popup = popupTable( bhef_crowns_group , zcol = c( &quot;crown_group_class&quot; , &quot;count_trees&quot; , &quot;min_hgt_m&quot; , &quot;max_hgt_m&quot; , &quot;mean_hgt_m&quot; , &quot;count_trees_canopy&quot; , &quot;count_trees_subcanopy&quot; ) , row.numbers = FALSE , feature.id = FALSE ) ) Note: crown groups shown for only 50% of Rx Fire units (to enhance rendering performance). Crown group data for entire BHEF is still available. 4.8 Write Out Data if(overwrite_it == FALSE){ print(&quot;Proceeding to next section without processing or overwriting data...&quot;) }else{ # save cleaned data for reading to R later sf::st_write(crowns_group, &quot;../data/crowns_group.gpkg&quot;, append = FALSE) sf::st_write(tree_tops, &quot;../data/tree_tops.gpkg&quot;, append = FALSE) sf::st_write(crowns_sf, &quot;../data/crowns_sf.gpkg&quot;, append = FALSE) stars::write_stars(chm, &quot;../data/chm.tif&quot;, append = FALSE) stars::write_stars(crowns_st, &quot;../data/crowns_st.tif&quot;, append = FALSE) } "],["cover_analysis.html", "Section 5 Forest Cover Analysis 5.1 Set Contour Line Interval 5.2 Read Data 5.3 Post-Lidar Acquisition Treatment 5.4 Forest Cover Summary 5.5 Total Area by Crown Group Class 5.6 No Treatment Post-Lidar Area by Crown Group Class 5.7 Spatial Arrangement by Crown Group Class 5.8 Rx Fire Unit Summary 5.9 Rx Fire Info Sheets 5.10 Rx Fire Info Packet", " Section 5 Forest Cover Analysis # turn off the s2 processing ## https://stackoverflow.com/questions/68478179/how-to-resolve-spherical-geometry-failures-when-joining-spatial-data sf::sf_use_s2(FALSE) 5.1 Set Contour Line Interval ####################################################### ####################################################### # Set Contour Line Interval ####################################################### ####################################################### contour_int_m &lt;- 5 5.2 Read Data Vector data and forest cover data created in prior chapters. # read forests_bhnf &lt;- sf::st_read(&quot;../data/forests_bhnf.gpkg&quot;) bhef_boundary &lt;- sf::st_read(&quot;../data/bhef_boundary.gpkg&quot;) bhef_harvests &lt;- sf::st_read(&quot;../data/bhef_harvests.gpkg&quot;) bhef_tsi &lt;- sf::st_read(&quot;../data/bhef_tsi.gpkg&quot;) research_plots &lt;- sf::st_read(&quot;../data/research_plots.gpkg&quot;) stem_map &lt;- sf::st_read(&quot;../data/stem_map.gpkg&quot;) rx_fire &lt;- sf::st_read(&quot;../data/rx_fire.gpkg&quot;) # # forest cov crowns_group &lt;- sf::st_read(&quot;../data/crowns_group.gpkg&quot;) # tree_tops &lt;- sf::st_read(&quot;../data/tree_tops.gpkg&quot;) # chm &lt;- stars::read_stars(&quot;../data/chm.tif&quot;) # elevation bhef_elev &lt;- stars::read_stars(&quot;../data/bhef_elev.tif&quot;) 5.2.1 Data Preparation # create dir for pdf plots hey_dir &lt;- &quot;../data/pdf&quot; if(dir.exists(hey_dir)==FALSE){ dir.create(hey_dir) }else{ # delete all files if folder exists file.remove(list.files(hey_dir, full.names = TRUE)) } ################################################ ################################################ # add colors to the crowns group ################################################ ################################################ all_classes &lt;- c(sort(unique(crowns_group$crown_group_class)), &quot;Non-Tree Cover&quot;, &quot;Post-Lidar Treatment&quot;) col_data &lt;- data.frame( crown_group_class = all_classes , crown_group_class_color = c( viridis::turbo(n = length(unique(crowns_group$crown_group_class)), alpha = 0.5) , &quot;#48526B80&quot; , &quot;#9E967780&quot; ) ) %&gt;% dplyr::mutate(row_n = dplyr::row_number()) # set up for plotting col_data$crown_group_class &lt;- factor(col_data$crown_group_class, levels=unique(col_data$crown_group_class)) scale_fill_manual_values_fill &lt;- col_data$crown_group_class_color names(scale_fill_manual_values_fill) &lt;- paste(col_data$crown_group_class) # attach crowns_group &lt;- crowns_group %&gt;% # dplyr::select(-crown_group_class_color) %&gt;% dplyr::left_join(col_data, by = c(&quot;crown_group_class&quot;=&quot;crown_group_class&quot;)) ################################################ ################################################ # create contour data ################################################ ################################################ # sequence by 5&#39;s to get 5m breaks list for contour seq_brk &lt;- seq(0, 40000, contour_int_m) # create contour data bhef_contour &lt;- bhef_elev %&gt;% stars::st_contour( na.rm = TRUE , contour_lines = FALSE , breaks = # classInt::classIntervals(na.omit(as.vector(x[[1]])))$brks seq_brk[ seq_brk &gt; min(na.omit(as.vector(bhef_elev[[1]]))) - contour_int_m &amp; seq_brk &lt; max(na.omit(as.vector(bhef_elev[[1]]))) + contour_int_m ] ) 5.2.2 Read NAIP Data National Agriculture Imagery Program (NAIP) imagery for the BHEF was manually ;/ downloaded from the USGS Science Data Explorer. ################################################ ################################################ # load naip tif with stars ################################################ ################################################ naip_st &lt;- stars::read_stars(&quot;../data/naip/bhef_naip_20200809_1m.tif&quot;) # crop naip_st &lt;- naip_st %&gt;% sf::st_crop(., sf::st_buffer(sf::st_transform(bhef_boundary, crs = sf::st_crs(naip_st)), dist = 500)) %&gt;% setNames(&quot;value&quot;) %&gt;% dplyr::mutate(value = ifelse(is.na(value), 0, value)) # black out missing band values # plot(naip_st %&gt;% dplyr::slice(band, 1:3), axes = TRUE) # plot(naip_st[,,,3:1], axes = TRUE) # set rgb image # band 3 = red, band 2 = green, band 1 = blue naip_rgb &lt;- stars::st_rgb( naip_st[,,,3:1] , dimension = 3 , use_alpha = FALSE # , stretch = &quot;histogram&quot; , probs = c(0.005, 0.995) , stretch = &quot;percent&quot; ) 5.3 Post-Lidar Acquisition Treatment Lidar data was collected in 2017. Spatially identify areas within BHEF where timber harvest and TSI treatments occurred in 2017 or later. # find harvests after lidar collection temp_harvests &lt;- bhef_harvests %&gt;% dplyr::filter(year_id &gt;= 2017) %&gt;% sf::st_intersection(bhef_boundary) %&gt;% sf::st_union() %&gt;% sf::st_as_sf() %&gt;% dplyr::mutate(temp_var = &quot;harvests&quot;) %&gt;% dplyr::select(temp_var) temp_tsi &lt;- bhef_tsi %&gt;% dplyr::filter(year_id &gt;= 2017) %&gt;% sf::st_intersection(bhef_boundary) %&gt;% sf::st_union() %&gt;% sf::st_as_sf() %&gt;% dplyr::mutate(temp_var = &quot;tsi&quot;) %&gt;% dplyr::select(temp_var) temp_i &lt;- sf::st_intersection(temp_harvests, temp_tsi) %&gt;% sf::st_union() %&gt;% sf::st_as_sf() %&gt;% dplyr::mutate(treatment_type_grp = &quot;Harvest &amp; TSI&quot;) %&gt;% dplyr::select(treatment_type_grp) harvests_post_lidar &lt;- rbind( temp_i , sf::st_difference(temp_harvests, temp_i) %&gt;% sf::st_union() %&gt;% sf::st_as_sf() %&gt;% dplyr::mutate(treatment_type_grp = &quot;Harvest&quot;) %&gt;% dplyr::select(treatment_type_grp) , sf::st_difference(temp_tsi, temp_i) %&gt;% sf::st_union() %&gt;% sf::st_as_sf() %&gt;% dplyr::mutate(treatment_type_grp = &quot;TSI&quot;) %&gt;% dplyr::select(treatment_type_grp) ) # write data sf::st_write(harvests_post_lidar, &quot;../data/harvests_post_lidar.gpkg&quot;, append = FALSE) # plot ggplot() + geom_sf(data = harvests_post_lidar , aes(fill = treatment_type_grp) , lwd = 0 , alpha = 0.8 ) + geom_sf(data = bhef_boundary, alpha = 0, lwd = 1, color = &quot;black&quot;, linetype = &quot;dashed&quot;) + geom_sf(data = rx_fire, alpha = 0, lwd = 1, color = &quot;orangered&quot;) + geom_sf_label(data = rx_fire, aes(label = unit) , label.size = NA , alpha = 0 , size = 3 ) + # geom_sf_label(data = harvests_post_lidar, aes(label = year_id) # , label.size = NA # , alpha = 0 # , size = 2.5 # ) + coord_sf(expand = F) + scale_fill_viridis_d(option = &quot;viridis&quot;) + labs( title = &quot;BHEF Post-Lidar Acquisition Timber Harvests &amp; TSI&quot; , subtitle = paste0(&quot;Rx fire units&quot;) , caption = paste0( &quot;*Percent of BHEF Area Treated Post-Lidar: &quot; , scales::percent( as.numeric(sum(sf::st_area(harvests_post_lidar))) / as.numeric(sum(sf::st_area(bhef_boundary))) , accuracy = 0.1 ) ) ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.title = element_blank() , axis.text = element_text(size = 7) , panel.border = element_blank() , plot.title = element_text(size = 12, face = &quot;bold&quot;, margin = margin(0,0,2,0)) , plot.subtitle = element_text(size=8, face=&quot;italic&quot;, color=&quot;orangered&quot;, margin = margin(0,0,0,0)) , plot.caption = element_text(size=10, face=&quot;bold.italic&quot;) ) # save plot ggplot2::ggsave( filename = paste0(&quot;../data/pdf/post_lidar_bhef_tmbrhrvst.pdf&quot;) , plot = ggplot2::last_plot() , width = 8.5 , height = 11 , units = &quot;in&quot; , dpi = &quot;print&quot; ) qpdf::pdf_rotate_pages(&quot;../data/pdf/post_lidar_bhef_tmbrhrvst.pdf&quot;, angle = 270, output = &quot;../data/pdf/00post_lidar_bhef_tmbrhrvst.pdf&quot;) file.remove(&quot;../data/pdf/post_lidar_bhef_tmbrhrvst.pdf&quot;) There have been 292 hectares in BHEF with timber harvest treatments completed after the lidar acquisition in 2017. This represents 21.2% of the total BHEF area (1,378 hectares). 5.3.1 Join Treatments to Rx Fire Units rx_fire &lt;- rx_fire %&gt;% dplyr::left_join( rx_fire %&gt;% dplyr::select(unit) %&gt;% sf::st_intersection( sf::st_union(harvests_post_lidar) ) %&gt;% dplyr::mutate(postlidar_harvest_area_m2 = as.numeric(sf::st_area(.))) %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(unit) %&gt;% dplyr::summarise(postlidar_harvest_area_m2 = sum(postlidar_harvest_area_m2)) %&gt;% dplyr::ungroup() %&gt;% dplyr::select(unit, postlidar_harvest_area_m2) , by = c(&quot;unit&quot; = &quot;unit&quot;) ) %&gt;% dplyr::mutate( has_postlidar_harvest = ifelse(!is.na(postlidar_harvest_area_m2), 1, 0) , postlidar_harvest_area_m2 = ifelse(!is.na(postlidar_harvest_area_m2), postlidar_harvest_area_m2, 0) , postlidar_harvest_area_ha = ifelse(!is.na(postlidar_harvest_area_m2), postlidar_harvest_area_m2/10000, 0) , area_m2 = as.numeric(sf::st_area(.)) , area_ha = as.numeric(sf::st_area(.)) / 10000 , pct_postlidar_harvest_area = postlidar_harvest_area_m2 / area_m2 ) # plot ggplot(data = rx_fire) + geom_col(aes(y = reorder(unit, pct_postlidar_harvest_area), x = area_ha) , width = 0.7, fill = &quot;navy&quot;, alpha = 0.5 ) + geom_col(aes(y = reorder(unit, pct_postlidar_harvest_area), x = postlidar_harvest_area_ha) , width = 0.7, fill = &quot;navy&quot;, alpha = 0.9 ) + geom_text( aes(y = reorder(unit, pct_postlidar_harvest_area) , x = 0 , label = scales::percent(pct_postlidar_harvest_area, accuracy = 1) ) , color = &quot;white&quot; , size = 3 , fontface = &quot;bold&quot; , hjust = -0.1 , vjust = 0.1 ) + labs( title = &quot;Percent of Rx Fire Unit Area with Treatment Post-Lidar Acquisition&quot; # , subtitle = &quot;within BHEF boundary and bounding box of research plot area&quot; ) + xlab(&quot;Area (ha)&quot;) + ylab(&quot;Rx Fire Unit&quot;) + scale_x_continuous(labels = scales::comma) + theme_bw() + theme( legend.position = &quot;none&quot; , plot.title = element_text(size = 12, face = &quot;bold&quot;, margin = margin(0,0,2,0)) , axis.text.y = element_text(size = 10, face = &quot;bold&quot;) ) 5.4 Forest Cover Summary In prior chapter, interlocking tree crowns were grouped together to form distinct tree crown classes. Experimental Forest-wide summary statistics were shown here. Explore the canopy cover distributions further. For reference, tree classes are based on Steel et al. 2021. Height thresholds were used to define canopy (&gt;8 m), subcanopy (2–8 m) and understory (1–2 m). Crown groups are defined by the number of trees in a crown group and the composition of canopy and subcanopy trees in the group: Individual Tree : single tree &gt;= 2m tall in 2017 (canopy or subcanopy) without interlocking crown Small Group - Canopy : 2-10 trees with interlocking crowns where 75% or more of the trees are canopy (&gt;8 m) Small Group - Subcanopy : 2-10 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m) Small Group - Mixed : 2-10 trees with interlocking crowns with neither canopy nor subcanopy comprising &gt;75% of trees Medium Group - Canopy : 11-40 trees with interlocking crowns where 75% or more of the trees are canopy (&gt;8 m) Medium Group - Subcanopy : 11-40 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m) Medium Group - Mixed : 11-40 trees with interlocking crowns with neither canopy nor subcanopy comprising &gt;75% of trees Continuous - Canopy : &gt;40 trees with interlocking crowns where 75% or more of the trees are canopy (&gt;8 m) Continuous - Subcanopy : &gt;40 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m) Continuous - Mixed : &gt;40 trees with interlocking crowns with neither canopy nor subcanopy comprising &gt;75% of trees # create data for defining crown class crown_group_class &lt;- c( &quot;Individual Tree&quot; , &quot;Small Group - Canopy&quot; , &quot;Small Group - Subcanopy&quot; , &quot;Small Group - Mixed&quot; , &quot;Medium Group - Canopy&quot; , &quot;Medium Group - Subcanopy&quot; , &quot;Medium Group - Mixed&quot; , &quot;Continuous - Canopy&quot; , &quot;Continuous - Subcanopy&quot; , &quot;Continuous - Mixed&quot; , &quot;Non-Tree Cover&quot; , &quot;Post-Lidar Treatment&quot; ) description &lt;- c( &quot;Single tree &gt;= 2m tall in 2017 (canopy or subcanopy) without interlocking crown&quot; , &quot;2-10 trees with interlocking crowns where 75% or more of the trees are canopy (&gt;8 m)&quot; , &quot;2-10 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m)&quot; , &quot;2-10 trees with interlocking crowns with neither canopy nor subcanopy comprising &gt;75% of trees&quot; , &quot;11-40 trees with interlocking crowns where 75% or more of the trees are canopy (&gt;8 m)&quot; , &quot;11-40 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m)&quot; , &quot;11-40 trees with interlocking crowns with neither canopy nor subcanopy comprising &gt;75% of trees&quot; , &quot;&gt;40 trees with interlocking crowns where 75% or more of the trees are canopy (&gt;8 m)&quot; , &quot;&gt;40 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m)&quot; , &quot;&gt;40 trees with interlocking crowns with neither canopy nor subcanopy comprising &gt;75% of trees&quot; , &quot;Any ground cover (vegetation or non-vegetation) less than 2 m in height in 2017&quot; , &quot;Timber harvest and/or TSI occured after the BHEF Lidar data acquisition in 2017 (based on FACTS)&quot; ) temp_dta &lt;- data.frame( Classification = crown_group_class , Description = description ) # Export PDF pdf(&quot;../data/pdf/01crown_class_desc.pdf&quot;, paper = &quot;USr&quot;, height = 8.5, width = 11) grid::grid.draw(gridExtra::tableGrob( temp_dta , theme = ttheme_default(base_size = 11, padding = unit(c(8, 8), &quot;mm&quot;)) )) dev.off() ## png ## 2 # table kable(temp_dta , format = &quot;html&quot; , caption = &quot;Crown Class Description&quot; , col.names = c( &quot;Classification&quot; , &quot;Description&quot; ) ) %&gt;% kable_styling(font_size = 11) %&gt;% column_spec(1, bold = TRUE, width = &quot;5em&quot;) %&gt;% column_spec(2, width = &quot;40em&quot;) Table 5.1: Crown Class Description Classification Description Individual Tree Single tree &gt;= 2m tall in 2017 (canopy or subcanopy) without interlocking crown Small Group - Canopy 2-10 trees with interlocking crowns where 75% or more of the trees are canopy (&gt;8 m) Small Group - Subcanopy 2-10 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m) Small Group - Mixed 2-10 trees with interlocking crowns with neither canopy nor subcanopy comprising &gt;75% of trees Medium Group - Canopy 11-40 trees with interlocking crowns where 75% or more of the trees are canopy (&gt;8 m) Medium Group - Subcanopy 11-40 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m) Medium Group - Mixed 11-40 trees with interlocking crowns with neither canopy nor subcanopy comprising &gt;75% of trees Continuous - Canopy &gt;40 trees with interlocking crowns where 75% or more of the trees are canopy (&gt;8 m) Continuous - Subcanopy &gt;40 trees with interlocking crowns where 75% or more of the trees are subcanopy (2-8 m) Continuous - Mixed &gt;40 trees with interlocking crowns with neither canopy nor subcanopy comprising &gt;75% of trees Non-Tree Cover Any ground cover (vegetation or non-vegetation) less than 2 m in height in 2017 Post-Lidar Treatment Timber harvest and/or TSI occured after the BHEF Lidar data acquisition in 2017 (based on FACTS) 5.5 Total Area by Crown Group Class # set up data bhef_area_ha &lt;- sum(as.numeric(sf::st_area(bhef_boundary))/10000) forestcov_area_ha &lt;- sum(as.numeric(sf::st_area(sf::st_intersection(crowns_group, bhef_boundary)))/10000, na.rm = TRUE) non_forestcov_area_ha &lt;- bhef_area_ha - forestcov_area_ha temp_dta &lt;- data.frame( crown_group_class = &quot;Non-Tree Cover&quot; , area_ha = non_forestcov_area_ha ) crowns_group_area_sum &lt;- crowns_group %&gt;% sf::st_intersection(bhef_boundary) %&gt;% dplyr::mutate(crown_group_area_ha = as.numeric(sf::st_area(.))/10000) %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(crown_group_class) %&gt;% dplyr::summarise(area_ha = sum(crown_group_area_ha, na.rm = TRUE)) %&gt;% dplyr::ungroup() %&gt;% dplyr::bind_rows(temp_dta) %&gt;% dplyr::mutate( pct_area = area_ha / bhef_area_ha ) %&gt;% dplyr::arrange(desc(area_ha)) # plot ggplot(data = crowns_group_area_sum) + geom_col(aes(y = reorder(crown_group_class, area_ha), x = area_ha, fill = area_ha), width = 0.7) + geom_text( aes(y = reorder(crown_group_class, area_ha), x = area_ha + 2, label = scales::comma(area_ha, accuracy = 1)) , color = &quot;black&quot; , size = 4 , fontface = &quot;bold&quot; # , position = position_dodge(0.9) , hjust = -0.1 , vjust = -0.5 ) + geom_text( aes(y = reorder(crown_group_class, area_ha), x = area_ha + 2, label = scales::percent(pct_area, accuracy = 1)) , color = &quot;black&quot; , size = 3 # , position = position_dodge(0.9) , hjust = -0.1 , vjust = 0.5 ) + labs( title = &quot;BHEF Area (ha) by Crown Group Class&quot; , subtitle = &quot;*Note: a tree is classified as cover &gt;= 2m tall in 2017 based on lidar acquisition&quot; ) + xlab(&quot;Area (ha)&quot;) + ylab(&quot;&quot;) + scale_x_continuous(labels = scales::comma) + scale_fill_viridis_c(alpha = 0.7, option = &quot;cividis&quot;, direction = -1) + theme_bw() + theme( legend.position = &quot;none&quot; , plot.title = element_text(size = 12, face = &quot;bold&quot;, margin = margin(0,0,2,0)) , plot.subtitle = element_text(size=8, face=&quot;italic&quot;, color=&quot;gray20&quot;, margin = margin(0,0,0,0)) , axis.text.y = element_text(size = 10, face = &quot;bold&quot;) ) # save plot ggplot2::ggsave( filename = paste0(&quot;../data/pdf/02cover_class_bhef_2017.pdf&quot;) , plot = ggplot2::last_plot() , width = 11 , height = 8.5 , units = &quot;in&quot; , dpi = &quot;print&quot; ) The total area of the BHEF is approximately 1,378 hectares (3,405 acres). 5.6 No Treatment Post-Lidar Area by Crown Group Class Remove area that has been treated (i.e. harvest and/or TSI) from BHEF area and identify cover class distribution. # set up data bhef_area_ha &lt;- sum(as.numeric(sf::st_area(sf::st_difference(bhef_boundary, sf::st_union(harvests_post_lidar))))/10000) forestcov_area_ha &lt;- sum(as.numeric(sf::st_area(sf::st_intersection(crowns_group, sf::st_difference(bhef_boundary, sf::st_union(harvests_post_lidar)))))/10000, na.rm = TRUE) non_forestcov_area_ha &lt;- bhef_area_ha - forestcov_area_ha temp_dta &lt;- data.frame( crown_group_class = &quot;Non-Tree Cover&quot; , area_ha = non_forestcov_area_ha ) crowns_group_area_sum_woharv &lt;- crowns_group %&gt;% sf::st_intersection(sf::st_difference(bhef_boundary, sf::st_union(harvests_post_lidar))) %&gt;% dplyr::mutate(crown_group_area_ha = as.numeric(sf::st_area(.))/10000) %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(crown_group_class) %&gt;% dplyr::summarise(area_ha = sum(crown_group_area_ha, na.rm = TRUE)) %&gt;% dplyr::ungroup() %&gt;% dplyr::bind_rows(temp_dta) %&gt;% dplyr::mutate( pct_area = area_ha / bhef_area_ha ) %&gt;% dplyr::arrange(desc(area_ha)) # plot ggplot(data = crowns_group_area_sum_woharv) + geom_col(aes(y = reorder(crown_group_class, area_ha), x = area_ha, fill = area_ha), width = 0.7) + geom_text( aes(y = reorder(crown_group_class, area_ha), x = area_ha + 2, label = scales::comma(area_ha, accuracy = 1)) , color = &quot;black&quot; , size = 4 , fontface = &quot;bold&quot; # , position = position_dodge(0.9) , hjust = -0.1 , vjust = -0.5 ) + geom_text( aes(y = reorder(crown_group_class, area_ha), x = area_ha + 2, label = scales::percent(pct_area, accuracy = 1)) , color = &quot;black&quot; , size = 3 # , position = position_dodge(0.9) , hjust = -0.1 , vjust = 0.5 ) + labs( title = &quot;No Treatment Post-Lidar BHEF Area (ha) by Crown Group Class&quot; , subtitle = &quot;*Note: a tree is classified as cover &gt;= 2m tall in 2017 based on lidar acquisition&quot; ) + xlab(&quot;Area (ha)&quot;) + ylab(&quot;&quot;) + scale_x_continuous(labels = scales::comma) + scale_fill_viridis_c(alpha = 0.7, option = &quot;cividis&quot;, direction = -1) + theme_bw() + theme( legend.position = &quot;none&quot; , plot.title = element_text(size = 12, face = &quot;bold&quot;, margin = margin(0,0,2,0)) , plot.subtitle = element_text(size=8, face=&quot;italic&quot;, color=&quot;gray20&quot;, margin = margin(0,0,0,0)) , axis.text.y = element_text(size = 10, face = &quot;bold&quot;) ) # save plot ggplot2::ggsave( filename = paste0(&quot;../data/pdf/03cover_class_bhef_noharv.pdf&quot;) , plot = ggplot2::last_plot() , width = 11 , height = 8.5 , units = &quot;in&quot; , dpi = &quot;print&quot; ) The total area of the BHEF which has not been treated (i.e. harvest and/or TSI) after the 2017 lidar acquisition is approximately 1,086 hectares (2,683 acres). 5.7 Spatial Arrangement by Crown Group Class # function to map for each cover class my_full_area_map &lt;- function(my_class,my_data){ #generate title my_title &lt;- paste0(my_class) my_caption &lt;- paste0( scales::percent( (crowns_group_area_sum %&gt;% dplyr::filter(crown_group_class==my_class))$pct_area , accuracy = 1 ) , &quot; of total BHEF Area&quot; ) #plot ( ggplot() + geom_sf(data = bhef_boundary, alpha = 0, lwd = 1, color = &quot;black&quot;, linetype = &quot;dashed&quot;) + geom_sf(data = rx_fire, alpha = 0, lwd = 1, color = &quot;orangered&quot;) + geom_sf(data = my_data %&gt;% dplyr::filter(crown_group_class==my_class) , fill = (col_data %&gt;% dplyr::filter(crown_group_class==my_class))$crown_group_class_color , lwd = NA ) + geom_sf_label(data = rx_fire, aes(label = unit) , label.size = NA , alpha = 0 , size = 2 ) + coord_sf(expand = F) + labs( title = my_title , subtitle = &quot;Spatial Arrangement on BHEF&quot; , caption = my_caption , x = &quot;&quot; , y = &quot;&quot; ) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , legend.title = element_blank() , axis.text = element_text(size = 7) , panel.border = element_blank() , plot.title = element_text(size = 12, face = &quot;bold&quot;, margin = margin(0,0,2,0)) , plot.subtitle = element_text(size=10, color=&quot;gray20&quot;, margin = margin(0,0,0,0)) , plot.caption = element_text(size=10, face=&quot;bold.italic&quot;) ) ) } sort(unique(crowns_group$crown_group_class)) %&gt;% purrr::map(my_full_area_map, my_data = crowns_group %&gt;% sf::st_intersection(bhef_boundary)) ## [[1]] ## ## [[2]] ## ## [[3]] ## ## [[4]] ## ## [[5]] ## ## [[6]] ## ## [[7]] ## ## [[8]] ## ## [[9]] ## ## [[10]] 5.8 Rx Fire Unit Summary # summarize area by coverage type temp_rx_crown &lt;- rx_fire %&gt;% dplyr::select(unit) %&gt;% sf::st_difference( sf::st_union(harvests_post_lidar) ) %&gt;% sf::st_intersection( crowns_group %&gt;% dplyr::select(crown_group_class) ) %&gt;% dplyr::mutate(area_m2 = as.numeric(sf::st_area(.))) %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::group_by(unit, crown_group_class) %&gt;% dplyr::summarise(area_m2 = sum(area_m2)) %&gt;% dplyr::ungroup() %&gt;% dplyr::select(unit, crown_group_class, area_m2) # join to base rx fire data rx_crown_sum &lt;- rx_fire %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::select(unit, postlidar_harvest_area_m2) %&gt;% dplyr::rename(area_m2 = postlidar_harvest_area_m2) %&gt;% dplyr::mutate(crown_group_class = &quot;Post-Lidar Treatment&quot;) %&gt;% dplyr::relocate(names(temp_rx_crown)) %&gt;% dplyr::bind_rows(temp_rx_crown) %&gt;% dplyr::left_join( rx_fire %&gt;% sf::st_set_geometry(NULL) %&gt;% dplyr::select(unit, area_m2) %&gt;% dplyr::rename(total_area_m2 = area_m2) , by = c(&quot;unit&quot; = &quot;unit&quot;) ) # find non-tree cover rx_crown_sum &lt;- rx_crown_sum %&gt;% dplyr::bind_rows( # find left over area rx_crown_sum %&gt;% dplyr::group_by(unit) %&gt;% dplyr::summarise(cov_area_m2 = sum(area_m2), total_area_m2 = max(total_area_m2)) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( area_m2 = total_area_m2 - cov_area_m2 , crown_group_class = &quot;Non-Tree Cover&quot; ) %&gt;% dplyr::select(names(rx_crown_sum)) %&gt;% dplyr::relocate(names(rx_crown_sum)) ) %&gt;% dplyr::mutate( pct_area = area_m2/total_area_m2 , area_ha = area_m2/10000 ) %&gt;% dplyr::arrange(unit, crown_group_class) %&gt;% dplyr::left_join(col_data, by = c(&quot;crown_group_class&quot; = &quot;crown_group_class&quot;)) # summarize for plot rx_crown_sum %&gt;% dplyr::mutate( cover = dplyr::case_when( crown_group_class %in% c(&quot;Non-Tree Cover&quot;, &quot;Post-Lidar Treatment&quot;) ~ crown_group_class , startsWith(crown_group_class, &quot;Continuous&quot;) ~ &quot;Continuous Tree Cover&quot; , TRUE ~ &quot;Sm/Med Grp. &amp; Indiv. Tree Cover&quot; ) , cover_num = dplyr::case_when( crown_group_class == &quot;Non-Tree Cover&quot; ~ 4 , crown_group_class == &quot;Post-Lidar Treatment&quot; ~ 3 , startsWith(crown_group_class, &quot;Continuous&quot;) ~ 1 , TRUE ~ 2 ) ) %&gt;% dplyr::group_by(unit, cover, cover_num) %&gt;% dplyr::summarise( pct_area = sum(pct_area) , area_m2 = sum(area_m2) , total_area_ha = max(total_area_m2)/10000 ) %&gt;% dplyr::ungroup() %&gt;% # plot ggplot() + geom_col(aes( y = reorder(unit, total_area_ha) , x = pct_area , fill = reorder(cover, -cover_num) ) , width = 0.7 ) + scale_fill_viridis_d(option = &quot;cividis&quot;, alpha = 1, direction = -1) + geom_text( aes( y = reorder(unit, total_area_ha) , x = pct_area , label = scales::percent( ifelse(pct_area &lt; 0.05, NA, pct_area) , accuracy = 1) , group = reorder(cover, -cover_num) ) , position = position_stack(vjust = 0.5) , color = &quot;white&quot; , size = 3 , fontface = &quot;bold&quot; # , hjust = -0.1 # , vjust = 0.1 ) + geom_text( aes( y = reorder(unit, total_area_ha) , x = 1.06 , label = paste0(scales::comma( total_area_ha , accuracy = 1) , &quot; ha&quot; ) ) , color = &quot;black&quot; , size = 4 , fontface = &quot;bold&quot; ) + labs( title = &quot;Cover Classification of Rx Fire Unit Area&quot; , subtitle = &quot;*Note: a tree is classified as cover &gt;= 2m tall in 2017 based on lidar acquisition&quot; ) + xlab(&quot;% of Area&quot;) + ylab(&quot;Rx Fire Unit&quot;) + scale_x_continuous(labels = scales::percent) + theme_bw() + theme( plot.title = element_text(size = 12, face = &quot;bold&quot;, margin = margin(0,0,2,0)) , plot.subtitle = element_text(size=8, face=&quot;italic&quot;, color=&quot;gray20&quot;, margin = margin(0,0,0,0)) , axis.text.y = element_text(size = 10, face = &quot;bold&quot;) , legend.title = element_blank() ) # save plot ggplot2::ggsave( filename = paste0(&quot;../data/pdf/04cover_class_by_unit.pdf&quot;) , plot = ggplot2::last_plot() , width = 11 , height = 8.5 , units = &quot;in&quot; , dpi = &quot;print&quot; ) 5.8.1 Rx Fire Unit Cover Class Create a plot function for cover class by fire unit. plot_cover_class_bars &lt;- function(my_unit){ ( # plot ggplot(data = rx_crown_sum %&gt;% dplyr::filter(unit == my_unit)) + geom_col( aes( y = reorder(crown_group_class, desc(crown_group_class)) , x = area_ha , fill = crown_group_class ) , width = 0.7 ) + scale_fill_manual(values = scale_fill_manual_values_fill) + geom_text( aes( y = reorder(crown_group_class, desc(crown_group_class)) , x = area_ha , label = scales::comma(area_ha, accuracy = 1) ) , color = &quot;black&quot; , size = 3 , fontface = &quot;bold&quot; # , position = position_dodge(0.9) , hjust = -0.1 , vjust = -0.2 ) + geom_text( aes( y = reorder(crown_group_class, desc(crown_group_class)) , x = area_ha , label = scales::percent(pct_area, accuracy = 1) ) , color = &quot;black&quot; , size = 2 # , position = position_dodge(0.9) , hjust = -0.1 , vjust = 0.9 ) + labs( # title = paste0(&quot;Rx Fire Unit: &quot;, my_unit) subtitle = &quot;Area (ha) by Crown Group Class&quot; , x = &quot;Area (ha)&quot; , y = &quot;&quot; ) + scale_x_continuous(labels = scales::comma, expand = expansion(mult = c(0, 0.1))) + theme_bw() + theme( legend.position = &quot;none&quot; # , plot.title = element_text(size = 12, face = &quot;bold&quot;, margin = margin(0,0,2,0)) , plot.subtitle = element_text(size=8, color=&quot;gray20&quot;, margin = margin(0,0,0,0)) , axis.text.y = element_text(size = 7, face = &quot;bold&quot;) , axis.text.x = element_text(size = 7) , axis.title.x = element_text(size = 7) ) ) } # print(plot_cover_class_bars(my_unit = rx_fire$unit[8])) 5.8.2 Rx Fire Unit Cover Map plot_cover_class_map &lt;- function(my_unit){ ( ######################################### ######################################### # map of unit w/ canopy ######################################### ######################################### ggplot() + stars::geom_stars( data = naip_rgb[ rx_fire %&gt;% dplyr::filter(unit == my_unit) %&gt;% sf::st_buffer(dist = 50) %&gt;% sf::st_transform(crs = sf::st_crs(naip_st)) %&gt;% sf::st_bbox() ] ) + scale_fill_identity(na.value = &quot;transparent&quot;) + # !!! don&#39;t take this out or RGB plot will kill your computer geom_sf(data = rx_fire %&gt;% dplyr::filter(unit == my_unit) %&gt;% sf::st_transform(crs = sf::st_crs(naip_st)) , alpha = 0 , lwd = 1.5 , color = &quot;orangered&quot; ) + geom_sf(data = crowns_group %&gt;% sf::st_crop( rx_fire %&gt;% dplyr::filter(unit == my_unit) %&gt;% sf::st_buffer(dist = 50) %&gt;% sf::st_bbox() ) %&gt;% sf::st_transform(crs = sf::st_crs(naip_st)) , lwd = NA , aes(fill = crown_group_class_color) ) + geom_sf(data = harvests_post_lidar %&gt;% # sf::st_union() %&gt;% sf::st_crop( rx_fire %&gt;% dplyr::filter(unit == my_unit) %&gt;% sf::st_buffer(dist = 50) %&gt;% sf::st_bbox() ) %&gt;% sf::st_transform(crs = sf::st_crs(naip_st)) , color = &quot;blue&quot; , lwd = 1.5 , fill = (col_data %&gt;% dplyr::filter(crown_group_class == &quot;Post-Lidar Treatment&quot;))$crown_group_class_color # , alpha = 0.4 ) + labs( title = paste0(&quot;Rx Fire Unit: &quot; , my_unit , &quot; (&quot; , scales::comma((rx_fire %&gt;% dplyr::filter(unit == my_unit))$area_ha, accuracy = 1) , &quot; ha | &quot; , scales::comma((rx_fire %&gt;% dplyr::filter(unit == my_unit))$area_m2/4047, accuracy = 1) , &quot; ac)&quot; ) , subtitle = ifelse( (rx_fire %&gt;% dplyr::filter(unit == my_unit))$has_postlidar_harvest == 1 , &quot;**This unit has post-lidar treatment (blue boundary)&quot; , &quot;&quot; ) ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme( legend.position = &quot;none&quot; , legend.direction = &quot;horizontal&quot; , legend.title = element_blank() , axis.text = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , panel.border = element_blank() , plot.title = element_text(size = 14, face = &quot;bold&quot;, margin = margin(0,0,2,0)) , plot.subtitle = element_text(size=9, face=&quot;bold.italic&quot;, color=&quot;blue&quot;, margin = margin(0,0,0,0)) ) ) } # print(plot_cover_class_map(my_unit = rx_fire$unit[1])) 5.8.3 Rx Fire Unit Contour plot_contour_map &lt;- function(my_unit){ ( ######################################### ######################################### # map of unit w/ contour ######################################### ######################################### # plot ggplot() + geom_raster( data = bhef_elev %&gt;% terra::rast() %&gt;% terra::crop( rx_fire %&gt;% dplyr::filter(unit == my_unit) %&gt;% sf::st_buffer(dist = 50) %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% terra::vect() ) %&gt;% as.data.frame(xy=T) %&gt;% dplyr::rename(elev = 3) , mapping = aes(x=x,y=y,fill=elev) ) + # stars::geom_stars(data = bhef_elev[ # rx_fire %&gt;% dplyr::filter(unit == my_unit) %&gt;% # sf::st_buffer(dist = 50) %&gt;% # sf::st_bbox() # ]) + geom_sf(data = bhef_contour %&gt;% sf::st_crop( rx_fire %&gt;% dplyr::filter(unit == my_unit) %&gt;% sf::st_buffer(dist = 50) %&gt;% sf::st_bbox() ) , alpha = 0 , lwd = 0.5 , color = &quot;gray30&quot; , show.legend = FALSE ) + geom_sf(data = rx_fire %&gt;% dplyr::filter(unit == my_unit) , alpha = 0 , lwd = 1.5 , color = &quot;orangered&quot; , show.legend = FALSE ) + scale_fill_viridis_c( option = &quot;viridis&quot; , alpha = 0.9 , na.value = &quot;transparent&quot; , breaks = scales::extended_breaks(n = 6) , labels = scales::comma ) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( subtitle = paste0(&quot;Contour lines are at &quot; , as.character(contour_int_m) , &quot;-m (~&quot; , as.character(round(contour_int_m * 3.281, 1)) , &quot;-ft) intervals&quot; ) , fill = &quot;Elev. (m)&quot; , x = &quot;&quot; , y = &quot;&quot; ) + theme_bw() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.box.margin = margin(-21,0,2,0) , legend.text = element_text(size = 7, angle = 25, hjust = 0.7) , legend.title = element_text(size = 7) , axis.text = element_blank() # , axis.text.y = element_text(size = 7) # , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , panel.border = element_blank() , plot.subtitle = element_text(size=9, face=&quot;italic&quot;, color=&quot;gray20&quot;, margin = margin(0,0,0,0)) ) ) } # print(plot_contour_map(my_unit = rx_fire$unit[1])) 5.8.4 Rx Fire Unit Insert plot_small_map &lt;- function(my_unit){ ( ggplot() + geom_sf(data = bhef_boundary, alpha = 0, lwd = 1, color = &quot;black&quot;, linetype = &quot;dashed&quot;) + geom_sf(data = rx_fire, alpha = 0, lwd = 0.7, color = &quot;orangered&quot;) + geom_sf( data = rx_fire %&gt;% dplyr::filter(unit == my_unit) , fill = &quot;black&quot; , alpha = 0.2 , lwd = 1.5 , color = &quot;orangered3&quot; ) + geom_sf_label( data = rx_fire , aes(label = unit) , label.size = NA , alpha = 0 , size = 2.5 ) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_bw() + theme( axis.text = element_text(size = 5.5) , axis.text.x = element_text(angle = 35) , panel.border = element_blank() ) ) } # print(plot_small_map(my_unit = rx_fire$unit[11])) 5.9 Rx Fire Info Sheets Create info sheets for each Rx Fire unit. # # set up plot legend once # p_legend &lt;- # ggplot(col_data) + # geom_col( # aes( # x = row_n # , y = 1 # , fill = crown_group_class # ) # ) + # scale_fill_manual(values = scale_fill_manual_values_fill) + # geom_text( # aes( # x = row_n # , y = 0.5 # , label = crown_group_class # ) # , size = 2.5 # , fontface = &quot;bold&quot; # , angle = 90 # , color = &quot;black&quot; # ) + # theme_nothing() # loop through all units to create pdf export for (i in 1:nrow(rx_fire)) { # for (i in c(1,3)) { # plots p_class_map &lt;- plot_cover_class_map(my_unit = rx_fire$unit[i]) p_class_bars &lt;- plot_cover_class_bars(my_unit = rx_fire$unit[i]) p_contour_map &lt;- plot_contour_map(my_unit = rx_fire$unit[i]) p_small_map &lt;- plot_small_map(my_unit = rx_fire$unit[i]) # arrange plots on one page info_sht &lt;- print( ggpubr::ggarrange( p_class_map , ggpubr::ggarrange( p_small_map , p_contour_map , p_class_bars , nrow = 1 , ncol = 3 , widths = c(0.5, 1.2, 1) ) , nrow = 2 , ncol = 1 , heights = c(1.7, 1) # , align = &quot;hv&quot; ) ) # export pdf ggplot2::ggsave( filename = paste0(&quot;../data/pdf/unit&quot;, sprintf(&quot;%02d&quot;, as.numeric(rx_fire$unit[i])),&quot;.pdf&quot;) , plot = info_sht , width = 11 , height = 8.5 , units = &quot;in&quot; , dpi = &quot;print&quot; ) } 5.10 Rx Fire Info Packet Combine info sheets for each Rx Fire unit into full packet for printing. # combine all pdfs together pdfs &lt;- sort(list.files(&quot;../data/pdf&quot;, pattern = &quot;\\\\.pdf$&quot;, full.names = TRUE)) # combine with pdftools pdftools::pdf_combine( pdfs , output = paste0( &quot;../data/pdf/&quot; , &quot;BHEF_RxFire_Plan_&quot; , gsub(&quot;-&quot;, &quot;&quot;, Sys.Date()) , &quot;.pdf&quot; ) ) ## [1] &quot;C:\\\\Data\\\\usfs\\\\bhef_rxfire_plan\\\\data\\\\pdf\\\\BHEF_RxFire_Plan_20230602.pdf&quot; "],["sample_canopycov_hli.html", "Section 6 Sample by Canopy Cover and HLI 6.1 Read Data 6.2 Aspect and HLI 6.3 Tree Canopy Cover 6.4 Aggregate and Crop to Rx fire Units 6.5 Classify Raster Grid 6.6 Sample Order and Export", " Section 6 Sample by Canopy Cover and HLI # turn off the s2 processing ## https://stackoverflow.com/questions/68478179/how-to-resolve-spherical-geometry-failures-when-joining-spatial-data sf::sf_use_s2(FALSE) 6.1 Read Data Vector data and forest cover data created in prior chapters. # read bhef_boundary &lt;- sf::st_read(&quot;../data/bhef_boundary.gpkg&quot;) # bhef_harvests &lt;- sf::st_read(&quot;../data/bhef_harvests.gpkg&quot;) # bhef_tsi &lt;- sf::st_read(&quot;../data/bhef_tsi.gpkg&quot;) rx_fire &lt;- sf::st_read(&quot;../data/rx_fire.gpkg&quot;) # # forest cov crowns_group &lt;- sf::st_read(&quot;../data/crowns_group.gpkg&quot;) crowns_rast &lt;- terra::rast(&quot;../data/crowns_st.tif&quot;) # chm &lt;- terra::rast(&quot;../data/chm.tif&quot;) %&gt;% # terra::aggregate(fact = 5, fun = &quot;mean&quot;, na.rm = T) # elevation bhef_elev &lt;- terra::rast(&quot;../data/bhef_elev.tif&quot;) # terra::aggregate(fact = 5, fun = &quot;mean&quot;, na.rm = T) 6.2 Aspect and HLI Aspect of a slope (the direction or azimuth that a slope faces) strongly influences potential direct incident radiation and temperature. Untransformed, aspect is a poor variable for quantitative analysis, since 1° is adjacent to 360° – the numbers are very different even though the aspect is about the same. The following equation for Heat Load Index (HLI) rescales aspect to a scale of zero to one, with zero being the coolest slope (northeast) and one being the warmest slope (southwest). HLI is a proxy for aspect-driven solar heating. \\[ \\textrm{Heat load index} = \\frac{1 - \\cos(\\theta - 45)}{2} \\] where \\(\\theta\\) = aspect in degrees east of north. While this and related equations are useful, they do not consider the steepness of the slope. For example, a 1° south-facing slope would receive the same heat load index as a 30° south-facing slope, even though the latter will be considerably warmer. HLI calculations have been developed which combine slope, folded aspect (i.e., “southwestness”), and latitude to estimate terrain-driven solar heating at a given location (McCune &amp; Keon 2002: eq. 2). To calculate HLI, we used equation 2 of McCune &amp; Keon 2002: eq. 2. Higher values of HLI are typical on steep southwesterly slopes, while low values are common on steep northeasterly slopes. Moderate values are common in flatter terrain and on northwesterly and southeasterly aspects. Aspect must first be “folded” about the north-south line, rescaling 0-360° to 0-180°, such that NE = NW, E = W, etc: \\[ \\textrm{Folded aspect°} = 180° \\, - \\, | Aspect° – 180° | \\] # convert elevation raster from terra to stars my_crs &lt;- 5070 # EPSG:5070 = NAD83/Conus Albers (units = meters) elev_stars_temp &lt;- stars::st_as_stars(bhef_elev |&gt; terra::project( paste0(&quot;EPSG:&quot;,my_crs) )) %&gt;% setNames(c(&quot;elev&quot;)) # extract latitude degrees from stars object lats_temp &lt;- sf::st_coordinates(elev_stars_temp) %&gt;% sf::st_as_sf(coords = c(&quot;x&quot;, &quot;y&quot;), crs = my_crs) %&gt;% sf::st_transform(crs = 4326) %&gt;% sf::st_coordinates() %&gt;% dplyr::as_tibble() %&gt;% setNames(c(&quot;longitude&quot;,&quot;latitude&quot;)) %&gt;% dplyr::select(latitude) gc() # hli function # This equation returns ln(Rad, MJ · cm–2 · yr–1). It can # be returned to an arithmetic scale with the EXP(x) # function. hli_fn &lt;- function(slope_rad, folded_aspect_rad, latitude_rad){ exp( (-1*1.236) + 1.350*cos(latitude_rad)*cos(slope_rad) + (-1*1.376)*cos(folded_aspect_rad)*sin(slope_rad)*sin(latitude_rad) + (-1*0.331)*sin(latitude_rad)*sin(slope_rad) + 0.375*sin(folded_aspect_rad)*sin(slope_rad) ) } # calculate slope and aspect from DEM topo_temp &lt;- c( elev_stars_temp , starsExtra::slope(elev_stars_temp) , starsExtra::aspect(elev_stars_temp) ) %&gt;% setNames( c(&quot;elev&quot;, &quot;slope_deg&quot;, &quot;aspect_deg&quot;) ) %&gt;% dplyr::mutate( slope_rad = pracma::deg2rad(as.numeric(slope_deg)) , aspect_rad = pracma::deg2rad(as.numeric(aspect_deg)) , folded_aspect_deg = 180 - abs(as.numeric(aspect_deg)-180) , folded_aspect_rad = pracma::deg2rad(folded_aspect_deg) , latitude_deg = lats_temp$latitude , latitude_rad = pracma::deg2rad(as.numeric(latitude_deg)) , hli = dplyr::case_when( hli_fn(slope_rad, folded_aspect_rad, latitude_rad) &gt; 1 ~ 1 , hli_fn(slope_rad, folded_aspect_rad, latitude_rad) &lt; 0 ~ 0 , TRUE ~ hli_fn(slope_rad, folded_aspect_rad, latitude_rad) ) ) # convert just HLI back to terra hli &lt;- terra::rast((topo_temp %&gt;% dplyr::select(hli))[]) %&gt;% terra::project( terra::crs(crowns_rast) ) %&gt;% # resample to align layers terra::resample(y=crowns_rast, method = &quot;bilinear&quot;) %&gt;% terra::crop(crowns_rast) # rename names(hli) &lt;- &quot;hli&quot; plot(hli, main = &quot;HLI&quot;) # does it have the same extent? terra::ext(hli) == terra::ext(crowns_rast) if(FALSE){ # smooth HLI with median value in matrix # d = 1 = 3x3 # d = 2 = 5x5 # d = 3 = 7x7 # fw_temp &lt;- terra::focalMat(hli, d = 2, type = &quot;rectangle&quot;) fw_temp &lt;- matrix(1,5,5) hli &lt;- terra::focal(hli, w = fw_temp, fun = &quot;median&quot;, na.rm=T) plot(hli, main = &quot;HLI smooth&quot;) # does it have the same extent? terra::ext(hli) == terra::ext(crowns_rast) } # aggregate to 25m resolution hli %&gt;% terra::aggregate(fact = 25, fun = &quot;median&quot;) %&gt;% plot(main = &quot;HLI aggregate&quot;) 6.3 Tree Canopy Cover The tree crown raster data represents tree crowns (interconnected crown groups or individual crowns) with minimum tree height of 2 meters was created here using lidR::dalponte2016. Values of this raster are tree crown id’s. # values crowns_rast %&gt;% terra::values() %&gt;% summary() # plot crowns_rast %&gt;% as.data.frame(xy=T) %&gt;% dplyr::rename(f=3) %&gt;% ggplot() + geom_raster(mapping=aes(x=x,y=y,fill=f)) + scale_fill_viridis_c() # zoom plot crowns_rast %&gt;% terra::crop( bhef_boundary %&gt;% sf::st_centroid() %&gt;% sf::st_buffer(10) ) %&gt;% as.data.frame(xy=T) %&gt;% dplyr::rename(f=3) %&gt;% ggplot() + geom_raster(mapping=aes(x=x,y=y,fill=as.factor(f))) + scale_fill_viridis_d(option=&quot;turbo&quot;) # mapview mv_temp &lt;- crowns_rast %&gt;% terra::crop( bhef_boundary %&gt;% sf::st_centroid() %&gt;% sf::st_buffer(500) ) %&gt;% stars::st_as_stars() mapview::mapviewOptions(homebutton = FALSE, basemaps = c(&quot;Esri.WorldImagery&quot;)) mapview::mapview(mv_temp, col.regions = &quot;forestgreen&quot;, na.color = &quot;transparent&quot;, legend = F) # reclass crowns as 1, else 0 # reclass matrix rcl_temp &lt;- c( crowns_rast %&gt;% terra::values() %&gt;% min(na.rm = T) , crowns_rast %&gt;% terra::values() %&gt;% max(na.rm = T) , 1 ) %&gt;% matrix(ncol=3, byrow=TRUE) # binary raster iscrown_rast &lt;- crowns_rast %&gt;% terra::classify( rcl = rcl_temp , include.lowest = T , others = 0 ) %&gt;% # update to 0/1 because na values are not 0 terra::subst(from=NA,to=0) # values iscrown_rast %&gt;% terra::values() %&gt;% summary() iscrown_rast %&gt;% terra::res() # plot iscrown_rast %&gt;% as.data.frame(xy=T) %&gt;% dplyr::rename(f=3) %&gt;% ggplot() + geom_raster(mapping=aes(x=x,y=y,fill=as.factor(f))) + geom_sf(data = bhef_boundary, fill = NA, color = &quot;black&quot;, lwd = 1.1) + scale_fill_viridis_d(na.value = &quot;transparent&quot;) # plot zoom iscrown_rast %&gt;% terra::crop( bhef_boundary %&gt;% sf::st_centroid() %&gt;% sf::st_buffer(10) ) %&gt;% as.data.frame(xy=T) %&gt;% dplyr::rename(f=3) %&gt;% ggplot() + geom_raster(mapping=aes(x=x,y=y,fill=as.factor(f))) + scale_fill_viridis_d(na.value = &quot;transparent&quot;) 6.4 Aggregate and Crop to Rx fire Units # select aggregate resolution: 25 = 25x25m grid agg_res &lt;- 25 # aggreaged and combine layers layers &lt;- c( iscrown_rast %&gt;% terra::aggregate(fact = agg_res, fun = &quot;mean&quot;) , hli %&gt;% terra::aggregate(fact = agg_res, fun = &quot;median&quot;) ) %&gt;% setNames(c(&quot;crowncov&quot;, &quot;hli&quot;)) # crop to rx fire units bounds layers &lt;- layers %&gt;% terra::mask( rx_fire %&gt;% sf::st_union() %&gt;% terra::vect() ) # plot nm_temp &lt;- c(&quot;% Canopy Cov.&quot;, &quot;HLI&quot;) plt_fn_temp &lt;- function(layer_n) { plt &lt;- layers[[layer_n]] %&gt;% as.data.frame(xy=T) %&gt;% dplyr::rename(f=3) %&gt;% ggplot() + geom_raster(mapping=aes(x=x,y=y,fill=f)) + geom_sf(data = bhef_boundary, alpha = 0, lwd = 1, color = &quot;black&quot;, linetype = &quot;dashed&quot;) + geom_sf(data = rx_fire, alpha = 0, lwd = 1, color = &quot;orangered&quot;) + geom_sf_label(data = rx_fire, aes(label = unit) , label.size = NA , alpha = 0 , size = 3 ) + coord_sf(expand = F) + scale_fill_viridis_c(option = (8-layer_n), alpha = 0.8) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( title = nm_temp[layer_n] , subtitle = paste0(&quot;Rx fire units&quot;) , x=&quot;&quot; , y=&quot;&quot; , fill = nm_temp[layer_n] ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.box.margin = margin(-21,0,2,0) , legend.text = element_text(size = 7, angle = 25, hjust = 0.7) , legend.title = element_text(size = 7) , axis.text = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , plot.title = element_text(size = 10, face = &quot;bold&quot;, margin = margin(0,0,2,0)) , plot.subtitle = element_text(size=8, face=&quot;italic&quot;, color=&quot;orangered&quot;, margin = margin(0,0,0,0)) , panel.border = element_blank() ) return(plt) } plt_list_temp &lt;- 1:(layers %&gt;% terra::nlyr()) %&gt;% purrr::map(plt_fn_temp) # combine cowplot::plot_grid( plotlist = plt_list_temp , nrow = 1 ) 6.5 Classify Raster Grid 6.5.1 Cutpoints cutlist &lt;- seq(0,1,0.2) # cutlist_df_temp &lt;- data.frame( hli = stats::quantile( layers$hli %&gt;% terra::values() , probs = cutlist , na.rm = T ) , crowncov = stats::quantile( layers$crowncov %&gt;% terra::values() , probs = cutlist , na.rm = T ) ) %&gt;% tibble::rownames_to_column(var=&quot;pct&quot;) %&gt;% tidyr::pivot_longer( cols = c(hli,crowncov) ) %&gt;% dplyr::group_by(name) %&gt;% dplyr::mutate( pct_n = readr::parse_number(pct) ) %&gt;% dplyr::arrange(name,pct_n) %&gt;% dplyr::mutate( n = dplyr::row_number()-1 , value_1 = dplyr::lag(value) ) %&gt;% dplyr::filter(n&gt;0) %&gt;% dplyr::mutate( f = factor( n , levels = 1:5 , labels = c(&quot;low&quot;,&quot;med.low&quot;,&quot;medium&quot;,&quot;med.high&quot;,&quot;high&quot;) , ordered = T ) , lab = dplyr::case_when( name == &quot;hli&quot; ~ scales::comma(value, accuracy = 0.01) , name == &quot;crowncov&quot; ~ scales::percent(value, accuracy = 1) ) , lab_1 = dplyr::case_when( name == &quot;hli&quot; ~ scales::comma(value_1, accuracy = 0.01) , name == &quot;crowncov&quot; ~ scales::percent(value_1, accuracy = 1) ) , name = dplyr::case_when( name == &quot;hli&quot; ~ &quot;HLI&quot; , name == &quot;crowncov&quot; ~ &quot;Canopy Cover&quot; ) ) %&gt;% ggplot(mapping = aes(y=f,x = (value_1+value)/2)) + geom_errorbar(mapping = aes(xmin=value_1,xmax=value,color=f)) + geom_point(mapping = aes(color = f)) + geom_text(mapping = aes(label = paste0(lab_1,&quot;\\nto &quot;,lab)) , size = 3 , hjust = 0 , vjust = -0.5 ) + facet_grid(cols = vars(name), scales = &quot;free_x&quot;) + scale_color_viridis_d(option=&quot;turbo&quot;) + scale_y_discrete(limits=rev) + labs( x = &quot;&quot; , y = &quot;Grouping&quot; ) + theme_light() + theme( legend.position = &quot;none&quot; , axis.text.x = element_blank() , axis.title.x = element_blank() , axis.line.x = element_blank() , strip.text = element_text(color=&quot;black&quot;, face=&quot;bold&quot;, size=11) ) 6.5.2 Canopy Cover and HLI Group Map rast_grp_class_fn &lt;- function(layer_n, pct_cut_list = seq(0,1,0.2)) { # classify based on percentile cuts_temp &lt;- stats::quantile( layers[[layer_n]] %&gt;% terra::values() , probs = pct_cut_list , na.rm = T ) # create classification raster based on percentiles rast_temp &lt;- layers[[layer_n]] %&gt;% classify( rcl = cuts_temp , include.lowest=TRUE , brackets=TRUE ) # recode to get rid of bracket labels and set index to 1 instead of 0 based rcl_temp &lt;- rast_temp %&gt;% terra::levels() %&gt;% purrr::pluck(1) %&gt;% dplyr::as_tibble() %&gt;% dplyr::mutate( old = value , new = value+1 ) %&gt;% dplyr::select(old,new) # classify rast_temp &lt;- rast_temp %&gt;% terra::classify(rcl=rcl_temp) %&gt;% terra::categories( value = rcl_temp %&gt;% dplyr::mutate(category = new) %&gt;% dplyr::select(new,category) %&gt;% dplyr::rename(id=new) ) # return return(rast_temp) } # create grouped raster stack layers_grp &lt;- 1:(layers %&gt;% terra::nlyr()) %&gt;% purrr::map(rast_grp_class_fn) %&gt;% terra::rast() %&gt;% setNames( names(layers) ) # plot nm_temp &lt;- c(&quot;% Canopy Cov.&quot;, &quot;HLI&quot;) plt_fn_temp &lt;- function(layer_n) { plt &lt;- layers_grp[[layer_n]] %&gt;% as.data.frame(xy=T) %&gt;% dplyr::rename(f=3) %&gt;% dplyr::mutate( f = factor( f , levels = 1:5 , labels = c(&quot;low&quot;,&quot;med.low&quot;,&quot;medium&quot;,&quot;med.high&quot;,&quot;high&quot;) , ordered = T ) ) %&gt;% ggplot() + geom_raster(mapping=aes(x=x,y=y,fill=f)) + geom_sf(data = bhef_boundary, alpha = 0, lwd = 1, color = &quot;black&quot;, linetype = &quot;dashed&quot;) + geom_sf(data = rx_fire, alpha = 0, lwd = 1, color = &quot;orangered&quot;) + geom_sf_label(data = rx_fire, aes(label = unit) , label.size = NA , alpha = 0 , size = 3 ) + coord_sf(expand = F) + scale_fill_viridis_d(option = &quot;turbo&quot;, alpha = 0.8) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( title = nm_temp[layer_n] , subtitle = paste0(&quot;Rx fire units&quot;) , x=&quot;&quot; , y=&quot;&quot; , fill = nm_temp[layer_n] ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.box.margin = margin(-21,0,2,0) , legend.text = element_text(size = 7) , legend.title = element_text(size = 7) , axis.text = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , plot.title = element_text(size = 10, face = &quot;bold&quot;, margin = margin(0,0,2,0)) , plot.subtitle = element_text(size=8, face=&quot;italic&quot;, color=&quot;orangered&quot;, margin = margin(0,0,0,0)) , panel.border = element_blank() ) return(plt) } # plot plt_list_temp &lt;- 1:(layers_grp %&gt;% terra::nlyr()) %&gt;% purrr::map(plt_fn_temp) # combine cowplot::plot_grid( plotlist = plt_list_temp , nrow = 1 ) 6.5.3 Map of grouped Canopy Cover and HLI l1_temp &lt;- layers_grp[[1]] %&gt;% stars::st_as_stars() l2_temp &lt;- layers_grp[[2]] %&gt;% stars::st_as_stars() mapview::mapviewOptions( homebutton = FALSE , basemaps = c(&quot;Esri.WorldImagery&quot;,&quot;OpenTopoMap&quot;) , na.color = &quot;transparent&quot; ) mapview::mapview( l1_temp , col.regions = viridis::turbo(n=5) , legend = TRUE , layer.name = names(layers_grp[[1]]) ) + mapview::mapview( l2_temp , col.regions = viridis::turbo(n=5) , legend = T , layer.name = names(layers_grp[[2]]) , hide = T ) 6.5.4 Combine Grouped Canopy Cover and HLI # combine layers for classification concat_rast &lt;- terra::concats(layers_grp[[1]], layers_grp[[2]]) %&gt;% setNames( (layers %&gt;% names() %&gt;% paste(collapse = &quot;_&quot;)) ) # data_frame concat_sf &lt;- c( concat_rast , layers ) %&gt;% terra::as.points() %&gt;% sf::st_as_sf(crs = sf::st_crs(bhef_boundary)) %&gt;% dplyr::mutate( x = sf::st_coordinates(geometry)[,1] #lon , y = sf::st_coordinates(geometry)[,2] #lat , crowncov_grp = stringr::str_split_i(crowncov_hli, &quot;_&quot;, 1) , hli_grp = stringr::str_split_i(crowncov_hli, &quot;_&quot;, 2) , crowncov_hli_filter = forcats::fct_other( f = crowncov_hli , keep = c( &quot;1_1&quot;,&quot;1_3&quot;,&quot;1_5&quot; , &quot;3_1&quot;,&quot;3_3&quot;,&quot;3_5&quot; , &quot;5_1&quot;,&quot;5_3&quot;,&quot;5_5&quot; ) , other_level = &quot;other&quot; ) , dplyr::across( c(crowncov_grp,hli_grp) , ~ factor( .x , levels = 1:5 , labels = c(&quot;low&quot;,&quot;med.low&quot;,&quot;medium&quot;,&quot;med.high&quot;,&quot;high&quot;) , ordered = T ) ) ) %&gt;% sf::st_intersection( rx_fire %&gt;% dplyr::select(unit) %&gt;% dplyr::rename(rx_fire_unit = unit) ) # plot concat_sf %&gt;% dplyr::filter(crowncov_hli_filter!=&quot;other&quot;) %&gt;% ggplot() + geom_tile(aes(x=x,y=y,fill=crowncov_hli_filter)) + # geom_sf(size = 0.2) + geom_sf(data = bhef_boundary, alpha = 0, lwd = 1, color = &quot;black&quot;, linetype = &quot;dashed&quot;) + geom_sf(data = rx_fire, alpha = 0, lwd = 1, color = &quot;orangered&quot;) + geom_sf_label(data = rx_fire, aes(label = unit) , label.size = NA , alpha = 0 , size = 3 ) + coord_sf(expand = F) + scale_fill_viridis_d(option = &quot;turbo&quot;, alpha = 0.8) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( title = &quot;Canopy Cover (1=low,3=med,5=hi)\\nx HLI (1=low,3=med,5=hi)&quot; , subtitle = paste0(&quot;Rx fire units&quot;) , x=&quot;&quot; , y=&quot;&quot; , fill = &quot;Canopy_HLI&quot; ) + theme_light() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) # , legend.box.margin = margin(-21,0,2,0) , legend.text = element_text(size = 7) , legend.title = element_text(size = 7) , axis.text = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , plot.title = element_text(size = 10, face = &quot;bold&quot;, margin = margin(0,0,2,0)) , plot.subtitle = element_text(size=8, face=&quot;italic&quot;, color=&quot;orangered&quot;, margin = margin(0,0,0,0)) , panel.border = element_blank() ) + guides(fill=guide_legend(nrow=3,byrow=TRUE)) 6.5.5 Example Rx Fire Unit unit_temp &lt;- &quot;22&quot; # plot concat_sf %&gt;% dplyr::filter(crowncov_hli_filter!=&quot;other&quot; &amp; rx_fire_unit==unit_temp) %&gt;% ggplot() + geom_tile(aes(x=x,y=y,fill=crowncov_hli_filter)) + geom_sf(size = 0.2, color = &quot;gray22&quot;) + geom_sf(data = rx_fire %&gt;% dplyr::filter(unit==unit_temp) , alpha = 0, lwd = 1, color = &quot;orangered&quot; ) + coord_sf(expand = F) + scale_fill_viridis_d(option = &quot;turbo&quot;, alpha = 0.8) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + labs( title = &quot;Canopy Cover (1=low,3=med,5=hi)\\nx HLI (1=low,3=med,5=hi)&quot; , subtitle = paste0(&quot;Rx fire unit &quot;, unit_temp) , x=&quot;&quot; , y=&quot;&quot; , fill = &quot;Canopy_HLI&quot; ) + theme_light() + theme( legend.position = &quot;top&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) # , legend.box.margin = margin(-21,0,2,0) , legend.text = element_text(size = 7) , legend.title = element_text(size = 7) , axis.text = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , plot.title = element_text(size = 10, face = &quot;bold&quot;, margin = margin(0,0,2,0)) , plot.subtitle = element_text(size=8, face=&quot;italic&quot;, color=&quot;orangered&quot;, margin = margin(0,0,0,0)) , panel.border = element_blank() ) + guides(fill=guide_legend(nrow=3,byrow=TRUE)) 6.5.6 Distribution of Canopy Cover and HLI by Rx Fire Unit dist_temp &lt;- concat_sf %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(rx_fire_unit, crowncov_hli_filter) %&gt;% dplyr::group_by(rx_fire_unit) %&gt;% dplyr::mutate( pct = n/sum(n) , tot = sum(n) , crowncov_hli_filter = crowncov_hli_filter %&gt;% forcats::fct_rev() ) %&gt;% dplyr::ungroup() # plot ggplot(data=dist_temp) + geom_col( mapping = aes(x = pct, y = rx_fire_unit, fill=crowncov_hli_filter) ,width = 0.7, alpha=0.8 ) + geom_text( mapping = aes(x = pct, y = rx_fire_unit, group=crowncov_hli_filter ,label = scales::percent(ifelse(pct&gt;=0.05,pct,NA), accuracy = 1) , fontface = &quot;bold&quot; ) , position = position_stack(vjust = 0.5) , color = &quot;black&quot;, size = 2.8 ) + geom_text( data = dist_temp %&gt;% dplyr::group_by(rx_fire_unit) %&gt;% dplyr::filter(dplyr::row_number()==1) , mapping = aes(x = -0.02, y = rx_fire_unit ,label = paste0(&quot;n=&quot; ,scales::comma(tot, accuracy = 1) ) ) , size = 3 , color = &quot;black&quot; , hjust = 0.7 ) + # scale_fill_brewer(type = &quot;div&quot;, palette = &quot;RdYlBu&quot;, direction = -1) + scale_fill_manual(values = rev(c( viridis::turbo( n= ((dist_temp %&gt;% dplyr::count(crowncov_hli_filter) %&gt;% nrow())-1) ) , &quot;gray&quot; ))) + scale_x_continuous(labels = scales::percent_format()) + labs( title = &quot;Canopy Cover (1=low,3=med,5=hi)\\nx HLI (1=low,3=med,5=hi)&quot; , fill = &quot;Canopy_HLI&quot; , y = &quot;Rx Fire Unit&quot; , x = latex2exp::TeX(paste0(&quot;% of Sample Plots (&quot;, agg_res,&quot;$\\\\textrm{m}^2$&quot;,&quot;)&quot;)) # , caption = nlab_temp ) + theme_light() + theme( legend.position = &quot;top&quot; , legend.title = element_text(size=7) , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , axis.title = element_text(size=9) , axis.text.x = element_text(size=7) , strip.text = element_text(color = &quot;black&quot;, face = &quot;bold&quot;) , plot.title = element_text(size = 9) ) + guides( fill = guide_legend(reverse = T, override.aes = list(alpha = 0.9), nrow = 4, byrow = T) ) 6.5.7 Matrix of Canopy Cover and HLI by Rx Fire Unit concat_sf %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(crowncov_hli_filter!=&quot;other&quot;) %&gt;% dplyr::count(rx_fire_unit, crowncov_grp, hli_grp, crowncov_hli_filter) %&gt;% dplyr::group_by(rx_fire_unit) %&gt;% dplyr::mutate( pct = n/sum(n) , tot = sum(n) ) %&gt;% dplyr::ungroup() %&gt;% # dplyr::filter(rx_fire_unit %in% c(&quot;1&quot;,&quot;11&quot;,&quot;22&quot;)) %&gt;% dplyr::mutate(rx_fire_unit = paste0(&quot;unit &quot;,rx_fire_unit)) %&gt;% ggplot( mapping = aes(y = crowncov_grp, x = hli_grp) ) + geom_tile(aes(fill = crowncov_hli_filter), color = &quot;white&quot;,alpha=0.8) + geom_text(aes(label = scales::comma(n,accuracy=1)), vjust = 0.5,size = 3) + geom_text(aes(label = scales::percent(pct,accuracy=0.1)), vjust = 2, size=2) + facet_grid( rows = vars(rx_fire_unit) # , switch = &quot;y&quot; ) + scale_fill_viridis_d(option = &quot;turbo&quot;) + scale_x_discrete(position = &quot;top&quot;) + scale_y_discrete(limits = rev) + labs( y = &quot;Canopy Cover&quot; , x = &quot;HLI&quot; , title = latex2exp::TeX(paste0(&quot;Matrix of Sample Plots (&quot;, agg_res,&quot;$\\\\textrm{m}^2$&quot;,&quot;)&quot;)) ) + theme_light() + theme( legend.position = &quot;none&quot; , panel.grid = element_blank() , plot.title = element_text(size = 9) , strip.text.y = element_text(angle = 0) , axis.title = element_text(face = &quot;bold&quot;, size = 12) # , strip.placement = &quot;outside&quot; ) The figure above excludes plots with a classification other than the Canopy Cover and HLI classes shown (e.g. HLI = med. low, Canopy Cover = med. high). 6.6 Sample Order and Export set.seed(11) concat_sf &lt;- concat_sf %&gt;% dplyr::ungroup() %&gt;% dplyr::relocate(rx_fire_unit) %&gt;% dplyr::mutate(rand=runif(dplyr::row_number())) %&gt;% dplyr::arrange(rx_fire_unit, crowncov_hli_filter, desc(rand)) %&gt;% dplyr::group_by(rx_fire_unit, crowncov_hli_filter) %&gt;% dplyr::mutate(sample_number = dplyr::row_number()) %&gt;% dplyr::select(-c(rand)) %&gt;% dplyr::ungroup() # export sf::st_write( concat_sf %&gt;% dplyr::filter( crowncov_hli_filter!=&quot;other&quot; &amp; sample_number &lt;= 30 ) ,&quot;../data/bhef_rxfire_hli_canopycov_samplepoints.gpkg&quot; , append = F ) write.csv( concat_sf %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter( crowncov_hli_filter!=&quot;other&quot; &amp; sample_number &lt;= 30 ) ,&quot;../data/bhef_rxfire_hli_canopycov_samplepoints.csv&quot; , append = F ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
